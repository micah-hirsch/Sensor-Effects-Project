---
title: "Sensor Effects Analysis"
author: "Micah Hirsch"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_float: true
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Purpose

The following report documents the data analysis conducted for the sensor effects project. All code for the data analysis and visualizations are provided below. This report also provides supplemental materials to accompany the manuscript.

All data analyses were conducted using R version 4.3.2.

```{r, echo = F, warning = F, message = F}

# Loading in the needed packages and data
library(rio) # install.packages("rio") 
library(tidyverse) # install.packages("tidyverse")
library(geometry) # install.packages("geometry")
library(patchwork) # install.packages("patchwork")
library(NatParksPalettes) #install.packages("NatParksPalettes")
library(glmmTMB) # install.packages("glmmTMB")
library(emmeans) # install.packages("emmeans")
library(lme4) # install.packages("lme4")
library(lmerTest) # install.packages("lmerTest")
library(robustlmm) # install.packages("robustlmm")
library(gt) # install.packages("gt")
library(gtsummary) # install.packages("gtsummary")
library(sjPlot) # install.packages("sjPlot")
library(ggpubr) # install.packages("ggpubr")
library(effectsize) # install.packages("effectsize")
library(ggsignif) # install.packages("ggsignif")
library(janitor) # install.packages("janitor")
library(snakecase) # install.packages("snakecase")

vowels <- rio::import("Data/Cleaned Data/vowel_measures.csv") |>
  dplyr::mutate(time_point = factor(time_point, levels = c("before", "sensors", "after")),
                group = factor(group, levels = c("Control", "PD")),
                sex = factor(sex, levels = c("Male", "Female")),
                vowel = factor(vowel, levels = c("i", "u", "ae", "a")),
                seg_type = factor(seg_type, levels = c("initial", "intrarater", "interrater")))

consonants <- rio::import("Data/Cleaned Data/consonant_measures.csv") |>
   dplyr::mutate(time_point = factor(time_point, levels = c("before", "sensors", "after")),
                group = factor(group, levels = c("Control", "PD")),
                sex = factor(sex, levels = c("Male", "Female")),
                consonant = factor(consonant, levels = c("s", "sh"), labels = c("/s/", "/Êƒ/")),
                seg_type = factor(seg_type, levels = c("initial", "intrarater", "interrater")))

artic_rate <- rio::import("Data/Cleaned Data/articulation_rate.csv") |>
  dplyr::mutate(time_point = factor(time_point, levels = c("before", "sensors", "after")),
                group = factor(group, levels = c("Control", "PD")), 
                sex = factor(sex, levels = c("Male", "Female")),
                phrase = as.factor(phrase),
                seg_type = factor(seg_type, levels = c("initial", "intrarater", "interrater")))

speakers <- artic_rate |>
  dplyr::select(speaker_id, group, sex, age) |>
  dplyr::distinct()

# Setting the color palette to be used in the figures
my_pal <- c("#550527", "#82B12F", "#FAA613")

alpha_level <- .05/8 # 8 models, correcting the alpha using Bonferroni method
```


# Speaker Demographics

Below is the demographic information for the speakers in this study. Overall, there were more control speakers than speakers with Parkinson's disease. The PD speakers were slightly older than the control speakers (but both groups within 1 SD of each other). There was a higher proportion of female speakers in the control group compared to the PD group.

```{r, message = F, warning = F}

demo_table <- speakers |>
  dplyr::select(-speaker_id) |>
  tbl_summary(
    by = group,
    statistic = list(all_continuous() ~ c("{mean} ({sd})")),
    digits = all_continuous() ~ 2,
    label = list(age ~ "Age",
                 sex ~ "Sex")) |>
  add_overall() |>
  as_gt()

demo_table

demo_table |>
  gtsave("Tables/speaker_demo.html")

```

# Checking Sensor Errors
Checking to see if/which individuals had sensors detach during data collection
```{r}
sensorErrors <- rio::import("Participant Information/ErrorCheck_2023-04-14_1219.csv") %>%
  dplyr::rename(speaker_id = `Sub #`) %>%
  arrange(speaker_id) %>%
  dplyr::filter(speaker_id %in% speakers$speaker_id)
```


# Articulation Rate

## Reliability

The audio files were segmented by two different research assistants. Each rater also re-segmented 20% of their own segments. Therefore, Pearson Product-Moment Correlation Coefficients were used to evaluate interrater and intrarater reliability. The results below show that interrater and intrarater reliability for articulation rate was strong.

Interrater Reliability
```{r, warning = F, message = F}

artic_rate_rel <- artic_rate |>
  tidyr::pivot_wider(names_from = seg_type,
                     values_from = artic_rate)

ar_inter <- artic_rate_rel |>
  dplyr::select(-intrarater) |>
  dplyr::filter(!is.na(interrater))

cor.test(ar_inter$initial, ar_inter$interrater, method = "pearson", use = "complete.obs")

```

Intrarater Reliability
```{r, warning = F, message = F}

ar_intra <- artic_rate_rel |>
  dplyr::select(-interrater) |>
  dplyr::filter(!is.na(intrarater))

cor.test(ar_intra$initial, ar_intra$intrarater, method = "pearson", use = "complete.obs")

```


```{r, echo = F, warning = F, message = F}

rm(ar_inter, ar_intra, artic_rate_rel, demo_table)

```


## Descriptives

Descriptive statistics for articulation rate across the three time points are shown below. Descriptively, articulation rate is increasing across time points for both speaker groups.

```{r, warning = F, message = F}

articRate_modelData <- artic_rate |>
  dplyr::filter(seg_type == "initial") |>
  dplyr::group_by(speaker_id, time_point) |>
  dplyr::summarize(artic_rate_m = mean(artic_rate)) |>
  dplyr::left_join(speakers, by = "speaker_id") |>
  ungroup()

articRate_modelData |>
  dplyr::select(c(group, time_point, artic_rate_m)) |>
  tbl_strata(
    strata = group,
    ~.x |>
      tbl_summary(
        by = time_point,
        statistic = list(all_continuous() ~ c("{mean} ({sd})")),
        digits = all_continuous() ~ 2,
        label = list(artic_rate_m ~ "Articulation Rate")
      ))

hist(articRate_modelData$artic_rate_m)
performance::check_distribution(articRate_modelData$artic_rate_m)

```

## Model

We are using linear mixed effects models to test the differences in articulation rate across the three time points (before, sensors, and after) for both speaker groups (control and PD). The model results below indicate an increase in articulation rate after sensor removal compared to before sensor placement. 

```{r, warning = F, message = F}

articRate_model <- lmerTest::lmer(artic_rate_m ~ time_point * group + sex + age +
                          (1 | speaker_id),
                        data = articRate_modelData)
summary(articRate_model)
performance::check_heteroscedasticity(articRate_model)
performance::check_normality(articRate_model)
performance::check_collinearity(articRate_model)

sjPlot::tab_model(
  articRate_model,
  pred.labels = c(
    "Intercept",
    "Time Point [Sensors]",
    "Time Point [After]",
    "Group [PD]",
    "Sex [Female]",
    "Age",
    "Time Point [Sensors] * Group [PD]",
    "Time Point [After] * Group [PD]"
  ),
  p.threshold = c(alpha_level, alpha_level, alpha_level),
  order.terms = c(1, 4, 5, 6, 2, 7, 3, 8),
  dv.labels = "Articulation Rate",
  file = "Tables/T3_articRate.html"
)

``` 


### Effect Size

The partial eta-squared values for the articulation rate model are shown below. Based on the results here, the effect of time point is large. The effect sizes for the main effect of group and the interaction between group and time point are small.

```{r, message = F, warning = F}

effectsize::eta_squared(articRate_model, alternative = "two.sided")

``` 

### Pairwise Comparisons

We ran pairwise comparisons using the emmeans package. The results below show the significant difference between the before and after time points in the model are primarily driven by the control speakers (this was the only significant contrast).

Cohen's d effect sizes were also calculated for these pairwise comparisons. The before and after contrast for the control speaker is significant and has a large effect size. No other comparisons had contrasts that were significant and/or had effect size confidence intervals that do not contain 0.

```{r, warning = F, message = F}

articRate_emm <- emmeans(articRate_model, specs = pairwise ~ time_point | group)

# Pairwise comparisons
articRate_pairwise <- articRate_emm$contrasts |>
  as.data.frame()

articRate_pairwise |>
  gt::gt() |>
  fmt_number(decimals = 4) |>
  gt::tab_style(
    style = list(cell_text(weight = "bold")),
    locations = cells_body(columns = estimate:p.value, rows = p.value <= alpha_level)
    ) |>
  gt::tab_header(
    title = "Pairwise Comparisons"
  )

# Effect sizes for the pairwise comparisons
articRate_pairwiseES <- emmeans::eff_size(
  articRate_emm,
  sigma = sigma(articRate_model),
  edf = df.residual(articRate_model)
) |>
  as.data.frame() |>
  janitor::clean_names() |>
  dplyr::mutate(
    contrast = str_replace_all(contrast, "\\*|\\(|\\)", ""),
    contrast = gsub("before", "Before", contrast),
    contrast = gsub("sensors", "Sensors", contrast),
    contrast = gsub("after", "After", contrast),
  ) |>
  dplyr::left_join(
    articRate_pairwise |>
      dplyr::mutate(
        contrast = gsub("before", "Before", contrast),
        contrast = gsub("sensors", "Sensors", contrast),
        contrast = gsub("after", "After", contrast)
      ) |>
      dplyr::select(p_value = p.value, contrast, group),
    by = join_by(contrast == contrast, group == group)
  ) 

articRate_pairwiseES |>
  gt() |>
  fmt_number(decimals = 4) |>
  gt::tab_style(
    style = list(cell_text(weight = "bold")),
    locations = cells_body(columns = effect_size:p_value, rows = p_value <= alpha_level)
    ) |>
  gt::tab_header(
    title = "Pairwise Effect Sizes"
  )

# Creating a data frame to be used for the annotation of sig effects in the plots
articRate_sigContrasts <- articRate_pairwise %>%
  dplyr::filter(contrast != "sensors - after") %>%
  dplyr::mutate(condition = case_when(
    grepl("sensors", contrast) ~ "With\nSensors",
    grepl("after", contrast) ~ "After\nSensors",
  ),
  sig = ifelse(p.value < alpha_level, "*", "n.s."))

```



## Plot

```{r, warning = F, message = F}
articRate_plotData_mainEffects <- articRate_model |>
  sjPlot::plot_model(type = "int") %>%
  .[["data"]] |>
  as.data.frame() |>
  dplyr::mutate(condition = factor(x, levels= c(1, 2, 3), 
                                   labels = c("Before\nSensors", "With\nSensors", "After\nSensors"))) %>%
  base::merge(., articRate_sigContrasts %>%
                dplyr::select(group, condition, sig),
              all = T)
 
articRate_plotData <- articRate_modelData |>
  dplyr::mutate(time_point = factor(time_point,
                                    levels = c("before",
                                               "sensors",
                                               "after"),
                                    labels = c("Before\nSensors",
                                               "With\nSensors",
                                               "After\nSensors")))


articRate_plot_summary <- articRate_plotData |>
  ggplot() +
  aes(
    x = time_point,
    y = artic_rate_m,
    color = group,
    group = speaker_id,
    shape = sex
  ) +
  geom_line(position = position_jitter(width = .15, seed = 1), alpha = .1) +
  geom_point(position = position_jitter(width = .15, seed = 1)) +
  theme_classic() +
  labs(x = NULL, y = "Articulation Rate (syl/s)", subtitle = "Summary Data") +
  guides(color = guide_legend(title = "Group"),
         shape = guide_legend(title = "Sex")) +
  scale_color_manual(values = c(my_pal[1], my_pal[2])) +
  theme(legend.position = "bottom", aspect.ratio = 1)

articRate_plot_RQ1 <- articRate_plotData |>
  dplyr::filter(time_point != "After\nSensors") |>
  ggplot() +
  aes(
    x = time_point,
    y = artic_rate_m,
    color = group,
    group = speaker_id,
    shape = sex
  ) +
  geom_line(
    #position = position_jitter(width = .1, seed = 1),
    alpha = .1,
            show.legend = FALSE) +
  #geom_point(position = position_jitter(width = .1, seed = 1), alpha = .1) +
  geom_line(
    data = articRate_plotData_mainEffects |>
      dplyr::filter(condition != "After\nSensors"),
    aes(
      x = condition,
      y = predicted,
      group = group,
      color = group
    ),
    linewidth = 1,
    inherit.aes = F,
    show.legend = FALSE
  ) +
  # Adding the significance labels
  ggrepel::geom_text_repel(
    data = articRate_plotData_mainEffects |>
      dplyr::filter(condition != "After\nSensors"),
    aes(
      x = condition,
      y = predicted,
      color = group,
      group = group,
      label = sig
    ),
    position = position_nudge(x = .1),
    hjust = 0,
    box.padding = 0,
    direction = "y",
    inherit.aes = F,
    show.legend = FALSE,
    seed = 1
  ) +
  theme_classic() +
  labs(x = NULL, y = "Articulation Rate (syl/s)", subtitle = "Research Question 1:\nSensor Effects") +
  guides(color = guide_legend(title = "Group"),
         shape = guide_legend(title = "Sex")) +
  scale_color_manual(values = c(my_pal[1], my_pal[2])) +
  theme(legend.position = "bottom", aspect.ratio = 1)
articRate_plot_RQ1

articRate_plot_RQ2 <- articRate_plotData |>
  dplyr::filter(time_point != "With\nSensors") |>
  ggplot() +
  aes(
    x = time_point,
    y = artic_rate_m,
    color = group,
    group = speaker_id,
    shape = sex
  ) +
  geom_line(
    #position = position_jitter(width = .1, seed = 1),
    alpha = .1,
            show.legend = FALSE) +
  #geom_point(position = position_jitter(width = .1, seed = 1), alpha = .1) +
  geom_line(
    data = articRate_plotData_mainEffects |>
      dplyr::filter(condition != "With\nSensors"),
    aes(
      x = condition,
      y = predicted,
      group = group,
      color = group
    ),
    linewidth = 1,
    inherit.aes = F,
    show.legend = FALSE
  ) +
  # Adding the significance labels
  ggrepel::geom_text_repel(
    data = articRate_plotData_mainEffects |>
      dplyr::filter(condition != "With\nSensors"),
    aes(
      x = condition,
      y = predicted,
      color = group,
      group = group,
      label = sig
    ),
    position = position_nudge(x = .1),
    hjust = 0,
    box.padding = 0,
    direction = "y",
    inherit.aes = F,
    show.legend = FALSE,
    seed = 1
  ) +
  
  theme_classic() +
  labs(x = NULL, y = "Articulation Rate (syl/s)", subtitle = "Research Question 2:\nPost-adaptation Effects") +
    guides(color = guide_legend(title = "Group"),
       shape = guide_legend(title = "Sex")) +
  scale_color_manual(values = c(my_pal[1], my_pal[2])) +
  theme(legend.position = "bottom", aspect.ratio = 1)



articRate_plot <- (articRate_plot_summary | articRate_plot_RQ1 | articRate_plot_RQ2) +
  plot_annotation('Articulation Rate') +
  patchwork::plot_layout(guides = "collect") &
  theme(legend.position='bottom')
articRate_plot

```
## Saving Data
Saving the data and cleaning up the environment.
```{r}
workingData_articRate <- list(
  modelData = articRate_modelData,
  pairwise = articRate_pairwise,
  pairwiseES = articRate_pairwiseES,
  plotData = articRate_plotData,
  plotData_mainEffects = articRate_plotData_mainEffects,
  sigContrasts = articRate_sigContrasts,
  emm = articRate_emm,
  model = articRate_model,
  plot = articRate_plot,
  plot_RQ1 = articRate_plot_RQ1,
  plot_RQ2 = articRate_plot_RQ2,
  plot_summary = articRate_plot_summary
)

rm(
  articRate_modelData,
  articRate_pairwise,
  articRate_pairwiseES,
  articRate_plotData,
  articRate_plotData_mainEffects,
  articRate_sigContrasts,
  articRate_emm,
  articRate_model,
  articRate_plot,
  articRate_plot_RQ1,
  articRate_plot_RQ2,
  articRate_plot_summary
)

base::saveRDS(workingData_articRate,
              file = "Data/workingData/data_articRate.RDS")
```


# Vowel Space Area

## Reliability

Similar to articulation rate, Pearson Product Moment Correlation Coefficients were used to assess interrater and intrarater reliability for vowel space area. The results indicate strong interrater and intrarater reliability for VSA.

Interrater Reliability
```{r, warning = F, message = F}

VSA_coords <- vowels |>
  dplyr::group_by(speaker_id, time_point, vowel, seg_type) |>
  dplyr::summarize(F1 = mean(f1),
                   F2 = mean(f2)) |>
  dplyr::ungroup()

VSA <- VSA_coords |>
  dplyr::group_by(speaker_id, time_point, seg_type) |>
  dplyr::mutate(VSA = (geometry::polyarea(F1, F2))/1000) |> # Converted to kHz
  dplyr::select(!c(vowel, F1, F2)) |>
  dplyr::distinct() |>
  dplyr::left_join(speakers, by = "speaker_id") |>
  ungroup()

VSA_rel <- VSA |>
  tidyr::pivot_wider(names_from = seg_type,
                     values_from = VSA)

VSA_inter <- VSA_rel |>
  dplyr::select(-intrarater) |>
  dplyr::filter(!is.na(interrater))

cor.test(VSA_inter$initial, VSA_inter$interrater, method = "pearson", use = "complete.obs")

```

Intrarater Reliability
```{r, warning = F, message = F}

VSA_intra <- VSA_rel |>
  dplyr::select(-interrater) |>
  dplyr::filter(!is.na(intrarater))

cor.test(VSA_intra$initial, VSA_intra$intrarater, method = "pearson", use = "complete.obs")

```



```{r, echo = F, warning = F, message = F}

rm(VSA_rel, VSA_intra, VSA_inter, VSA_coords)

```


## Descriptives

The descriptive statistics for VSA are below. Descriptively, VSA decreased during sensor placement for the control speakers and increased for the speakers with PD. VSA during sensor placement and after sensor removal were comparable within each of the the two speaker groups.

```{r, warning = F, message = F}

VSA_modelData <- VSA |>
  dplyr::filter(seg_type == "initial")

VSA_modelData |>
  dplyr::select(c(group, time_point, VSA)) |>
  tbl_strata(
    strata = group,
    ~.x |>
      tbl_summary(
        by = time_point,
        statistic = list(all_continuous() ~ c("{mean} ({sd})")),
        digits = all_continuous() ~ 2
      ))

hist(VSA_modelData$VSA)
hist(log(VSA_modelData$VSA))
performance::check_distribution(VSA_modelData$VSA)
```


## Model

A linear mixed effects model was ran to determine the change in VSA between the three time points (before, sensors, and after) for the two speaker groups (control and PD). None of the fixed effects were significant indicating VSA was comparable across the three time points for the two speaker groups.

```{r, warning = F, message = F}

VSA_model <- lmerTest::lmer(VSA ~ time_point * group + sex + age + (1 | speaker_id),
                 data = VSA_modelData)
summary(VSA_model)
anova(VSA_model)

performance::check_heteroscedasticity(VSA_model)
performance::check_normality(VSA_model)
performance::check_collinearity(VSA_model)
performance::check_model(VSA_model)


sjPlot::tab_model(
  VSA_model,
  pred.labels = c(
    "Intercept",
    "Time Point [Sensors]",
    "Time Point [After]",
    "Group [PD]",
    "Sex [Female]",
    "Age",
    "Time Point [Sensors] * Group [PD]",
    "Time Point [After] * Group [PD]"
  ),
  order.terms = c(1, 4, 5, 6, 2, 7, 3, 8),
  p.threshold = c(alpha_level, alpha_level, alpha_level),
  dv.labels = "Vowel Space Area",
  file = "Tables/T4_VSA.html"
)


```


### Effect Size

The partial eta-squared effect sizes show very small effects for the main effects of time point and group as well as their interaction.

```{r}

effectsize::eta_squared(VSA_model, alternative = "two.sided")

```

### Pairwise Comparisons

```{r, warning = F, message = F}

VSA_emm <- emmeans(VSA_model, specs = pairwise ~ time_point | group)

# Pairwise comparisons
VSA_pairwise <- VSA_emm$contrasts |>
  as.data.frame()

VSA_pairwise |>
  gt::gt() |>
  fmt_number(decimals = 4) |>
  gt::tab_style(
    style = list(cell_text(weight = "bold")),
    locations = cells_body(columns = estimate:p.value, rows = p.value <= alpha_level)
    ) |>
  gt::tab_header(
    title = "Pairwise Comparisons"
  )

# Effect sizes for the pairwise comparisons
VSA_pairwiseES <- emmeans::eff_size(
  VSA_emm,
  sigma = sigma(VSA_model),
  edf = df.residual(VSA_model)
) |>
  as.data.frame() |>
  janitor::clean_names() |>
  dplyr::mutate(
    contrast = str_replace_all(contrast, "\\*|\\(|\\)", ""),
    contrast = gsub("before", "Before", contrast),
    contrast = gsub("sensors", "Sensors", contrast),
    contrast = gsub("after", "After", contrast),
  ) |>
  dplyr::left_join(
    VSA_pairwise |>
      dplyr::mutate(
        contrast = gsub("before", "Before", contrast),
        contrast = gsub("sensors", "Sensors", contrast),
        contrast = gsub("after", "After", contrast)
      ) |>
      dplyr::select(p_value = p.value, contrast, group),
    by = join_by(contrast == contrast, group == group)
  ) 

VSA_pairwiseES |>
  gt() |>
  fmt_number(decimals = 4) |>
  gt::tab_style(
    style = list(cell_text(weight = "bold")),
    locations = cells_body(columns = effect_size:p_value, rows = p_value <= alpha_level)
    ) |>
  gt::tab_header(
    title = "Pairwise Effect Sizes"
  )

# Creating a data frame to be used for the annotation of sig effects in the plots
VSA_sigContrasts <- VSA_pairwise %>%
  dplyr::filter(contrast != "sensors - after") %>%
  dplyr::mutate(condition = case_when(
    grepl("sensors", contrast) ~ "With\nSensors",
    grepl("after", contrast) ~ "After\nSensors",
  ),
  sig = ifelse(p.value < alpha_level, "*", "n.s."))

```

## Plot
```{r, warning = F, message = F}
VSA_plotData_mainEffects <- VSA_model |>
  sjPlot::plot_model(type = "int") %>%
  .[["data"]] |>
  as.data.frame() |>
  dplyr::mutate(condition = factor(
    x,
    levels = c(1, 2, 3),
    labels = c("Before\nSensors", "With\nSensors", "After\nSensors")
  )) %>%
  base::merge(.,
              VSA_sigContrasts %>%
                dplyr::select(group, condition, sig),
              all = T)

VSA_plotData <- VSA_modelData |>
  dplyr::mutate(time_point = factor(
    time_point,
    levels = c("before", "sensors", "after"),
    labels = c("Before\nSensors", "With\nSensors", "After\nSensors")
  ))


VSA_plot_summary <- VSA_plotData |>
  ggplot() +
  aes(
    x = time_point,
    y = VSA,
    color = group,
    group = speaker_id,
    shape = sex
  ) +
  geom_line(position = position_jitter(width = .15, seed = 1), alpha = .1) +
  geom_point(position = position_jitter(width = .15, seed = 1)) +
  theme_classic() +
  labs(x = NULL,
       y = bquote('Vowel Space Area '(kHz ^ 2)),
       subtitle = "Summary Data") +
  guides(color = guide_legend(title = "Group"),
         shape = guide_legend(title = "Sex")) +
  scale_color_manual(values = c(my_pal[1], my_pal[2])) +
  theme(legend.position = "bottom", aspect.ratio = 1)

VSA_plot_RQ1 <- VSA_plotData |>
  dplyr::filter(time_point != "After\nSensors") |>
  ggplot() +
  aes(
    x = time_point,
    y = log(VSA),
    color = group,
    group = speaker_id,
    shape = sex
  ) +
  geom_line(
    # position = position_jitter(width = .1, seed = 1),
    alpha = .1, show.legend = FALSE) +
  # geom_point(position = position_jitter(width = .1, seed = 1), alpha = .2) +
  geom_line(
    data = VSA_plotData_mainEffects |>
      dplyr::filter(condition != "After\nSensors"),
    aes(
      x = condition,
      y = log(predicted),
      group = group,
      color = group
    ),
    linewidth = 1,
    inherit.aes = F,
    show.legend = FALSE
  ) +
  # Adding the significance labels
  ggrepel::geom_text_repel(
    data = VSA_plotData_mainEffects |>
      dplyr::filter(condition != "After\nSensors"),
    aes(
      x = condition,
      y = log(predicted),
      color = group,
      group = group,
      label = sig
    ),
    position = position_nudge(x = .1),
    hjust = 0,
    box.padding = 0,
    direction = "y",
    inherit.aes = F,
    show.legend = FALSE,
    seed = 1
  ) +
  theme_classic() +
  labs(x = NULL, y = "Vowel Space Area (log)", subtitle = "Research Question 1:\nSensor Effects") +
  guides(color = guide_legend(title = "Group"),
         shape = guide_legend(title = "Sex")) +
  scale_color_manual(values = c(my_pal[1], my_pal[2])) +
  theme(legend.position = "bottom", aspect.ratio = 1)

VSA_plot_RQ2 <- VSA_plotData |>
  dplyr::filter(time_point != "With\nSensors") |>
  ggplot() +
  aes(
    x = time_point,
    y = log(VSA),
    color = group,
    group = speaker_id,
    shape = sex
  ) +
  geom_line(#position = position_jitter(width = .1, seed = 1),
    alpha = .1, show.legend = FALSE) +
  #geom_point(position = position_jitter(width = .1, seed = 1), alpha = .2) +
  geom_line(
    data = VSA_plotData_mainEffects |>
      dplyr::filter(condition != "With\nSensors"),
    aes(
      x = condition,
      y = log(predicted),
      group = group,
      color = group
    ),
    linewidth = 1,
    inherit.aes = F,
    show.legend = FALSE
  ) +
  # Adding the significance labels
  ggrepel::geom_text_repel(
    data = VSA_plotData_mainEffects |>
      dplyr::filter(condition != "With\nSensors"),
    aes(
      x = condition,
      y = log(predicted),
      color = group,
      group = group,
      label = sig
    ),
    position = position_nudge(x = .1),
    hjust = 0,
    box.padding = 0,
    direction = "y",
    inherit.aes = F,
    show.legend = FALSE,
    seed = 1
  ) +
  theme_classic() +
  labs(x = NULL, y = "Vowel Space Area (log)", subtitle = "Research Question 2:\nPost-adaptation Effects") +
  guides(color = guide_legend(title = "Group"),
         shape = guide_legend(title = "Sex")) +
  scale_color_manual(values = c(my_pal[1], my_pal[2])) +
  theme(legend.position = "bottom", aspect.ratio = 1)


VSA_plot <- (VSA_plot_summary | VSA_plot_RQ1 | VSA_plot_RQ2) +
  plot_annotation('Vowel Space Area') +
  patchwork::plot_layout(guides = "collect") &
  theme(legend.position='bottom')
VSA_plot

```

## Saving Data
Saving the data and cleaning up the environment.
```{r}
workingData_VSA <- list(
  modelData = VSA_modelData,
  pairwise = VSA_pairwise,
  pairwiseES = VSA_pairwiseES,
  plotData = VSA_plotData,
  plotData_mainEffects = VSA_plotData_mainEffects,
  sigContrasts = VSA_sigContrasts,
  emm = VSA_emm,
  model = VSA_model,
  plot = VSA_plot,
  plot_RQ1 = VSA_plot_RQ1,
  plot_RQ2 = VSA_plot_RQ2,
  plot_summary = VSA_plot_summary
)

rm(
  VSA_modelData,
  VSA_pairwise,
  VSA_pairwiseES,
  VSA_plotData,
  VSA_plotData_mainEffects,
  VSA_sigContrasts,
  VSA_emm,
  VSA_model,
  VSA_plot,
  VSA_plot_RQ1,
  VSA_plot_RQ2,
  VSA_plot_summary,
  VSA
)

base::saveRDS(workingData_VSA,
              file = "Data/workingData/data_VSA.RDS")
```

## Exploratory VSA Model

Although we saw an interesting trend in VSA, the model above showed no significant fixed effects of VSA. It is possible that since we are observing an increase in articulation rate across the three time points, that this may impact the results were are seeing in the VSA model. Therefore, we are running an exploratory model for VSA by adding artic_rate as a covariate in the model. Based on the model output below, adding articulation rate as a covariate did not change the model output much.

```{r, warning = F, message = F, eval = F}

VSA_mod_2 <- dplyr::left_join(VSA_modelData, articRate_modelData, by=c("speaker_id", "time_point", "group", "sex", "age"))

VSA_model_2 <- lmerTest::lmer(VSA ~ time_point*group + artic_rate_m + (1|speaker_id), data = VSA_mod_2)

sjPlot::tab_model(VSA_model_2,
                  pred.labels = c("Intercept", "Time Point [Sensors]", "Time Point [After]",
                                   "Group [PD]", "Articulation Rate", 
                                   "Time Point [Sensors] * Group [PD]",
                                   "Time Point [After] * Group [PD]"),
                  dv.labels = "Vowel Space Area")

```


#### Exploratory Model Effect Size

Again, partial eta-squared values were calculated. All calculated effect sizes are small.

```{r, eval = F}

effectsize::eta_squared(VSA_model_2, alternative = "two.sided")

```

# Spectral Moment Analysis
# M1
## Reliability

Interrater Reliability
```{r, warning = F, message = F}

moment_mod <- consonants |>
  dplyr::select(speaker_id, group, sex, age, time_point, seg_type, consonant, m1, m2) |>
  dplyr::group_by(speaker_id, time_point, consonant, seg_type) |>
  dplyr::summarize(M1 = mean(m1), M2 = mean(m2)) |>
  dplyr::ungroup() |>
  dplyr::left_join(speakers, by = "speaker_id")
  

M1_rel <- moment_mod|>
  dplyr::select(speaker_id, group, sex, age, time_point, seg_type, consonant, M1) |>
  tidyr::pivot_wider(names_from = seg_type,
                     values_from = M1)


M1_inter <- M1_rel |>
  dplyr::select(-intrarater) |>
  dplyr::filter(!is.na(interrater))

cor.test(M1_inter$initial, M1_inter$interrater, method = "pearson", use = "complete.obs")

```

Intrarater Reliability
```{r, warning = F, message = F}

M1_intra <- M1_rel |>
  dplyr::select(-interrater) |>
  dplyr::filter(!is.na(intrarater))

cor.test(M1_intra$initial, M1_intra$intrarater, method = "pearson", use = "complete.obs")

```

```{r, echo = F, message = F, warning = F}

rm(M1_inter, M2_inter, M1_intra, M2_intra, M2_rel, M1_rel)

```

## /s/
Descriptive results for M1 and M2 for /s/ are shown below. The PD speakers appear to have a lower M1 values overall. However, both groups appear to have lower M1 values with sensors compared to before and after sensors. M2 appears to increase slightly with sensors for both PD and control speakers.

### Descriptives
```{r, warning = F, message = F}

moment_mod <- moment_mod |>
  dplyr::filter(seg_type == "initial")

moment_mod |>
  dplyr::filter(consonant == "/s/") |>
  dplyr::select(c(group, time_point, M1, M2)) |>
  tbl_strata(
    strata = group,
    ~.x |>
      tbl_summary(
        by = time_point,
        statistic = list(all_continuous() ~ c("{mean} ({sd})")),
        digits = all_continuous() ~ 2,
        label = list(M1 ~ "M1 /s/",
                     M2 ~ "M2 /s/")
      ))


```

### Model
A linear mixed effects model for M1 was conducted for /s/ to examine changes across the three time points (before, sensors, after) for the two speaker groups (control and PD). M1 significantly decreased with sensor placement and the PD group had an overall lower M1 values. 

```{r, warning = F, message = F}

M1s_modelData <- moment_mod |>
  dplyr::filter(consonant == "/s/")

hist(M1s_modelData$M1)
performance::check_distribution(M1s_modelData$M1)

M1s_model <- lmerTest::lmer(M1 ~ time_point * group + sex + age + (1 | speaker_id), data = M1s_modelData)

summary(M1s_model)
performance::check_heteroscedasticity(M1s_model)
performance::check_normality(M1s_model)
performance::check_collinearity(M1s_model)


sjPlot::tab_model( 
  M1s_model,
  pred.labels = c(
    "Intercept",
    "Time Point [Sensors]",
    "Time Point [After]",
    "Group [PD]",
    "Sex [Female]",
    "Age",
    "Time Point [Sensors] * Group [PD]",
    "Time Point [After] * Group [PD]"
  ),
  p.threshold = c(alpha_level),
  p.style = "numeric_stars",
  order.terms = c(1, 4, 5, 6, 2, 7, 3, 8),
  dv.labels = "M1 /s/"
)
```

#### Effect Size

The partial eta-squared effect sizes show very small effects for the main effects of time point and group as well as their interaction.

```{r}

effectsize::eta_squared(M1s_model, alternative = "two.sided")

```

#### Pairwise Comparisons

```{r, warning = F, message = F}

M1s_emm <- emmeans(M1s_model, specs = pairwise ~ time_point | group)

# Pairwise comparisons
M1s_pairwise <- M1s_emm$contrasts |>
  as.data.frame()

M1s_pairwise |>
  gt::gt() |>
  fmt_number(decimals = 4) |>
  gt::tab_style(
    style = list(cell_text(weight = "bold")),
    locations = cells_body(columns = estimate:p.value, rows = p.value <= alpha_level)
    ) |>
  gt::tab_header(
    title = "Pairwise Comparisons"
  )

# Effect sizes for the pairwise comparisons
M1s_pairwiseES <- emmeans::eff_size(
  M1s_emm,
  sigma = sigma(M1s_model),
  edf = df.residual(M1s_model)
) |>
  as.data.frame() |>
  janitor::clean_names() |>
  dplyr::mutate(
    contrast = str_replace_all(contrast, "\\*|\\(|\\)", ""),
    contrast = gsub("before", "Before", contrast),
    contrast = gsub("sensors", "Sensors", contrast),
    contrast = gsub("after", "After", contrast),
  ) |>
  dplyr::left_join(
    M1s_pairwise |>
      dplyr::mutate(
        contrast = gsub("before", "Before", contrast),
        contrast = gsub("sensors", "Sensors", contrast),
        contrast = gsub("after", "After", contrast)
      ) |>
      dplyr::select(p_value = p.value, contrast, group),
    by = join_by(contrast == contrast, group == group)
  ) 

M1s_pairwiseES |>
  gt() |>
  fmt_number(decimals = 4) |>
  gt::tab_style(
    style = list(cell_text(weight = "bold")),
    locations = cells_body(columns = effect_size:p_value, rows = p_value <= alpha_level)
    ) |>
  gt::tab_header(
    title = "Pairwise Effect Sizes"
  )

# Creating a data frame to be used for the annotation of sig effects in the plots
M1s_sigContrasts <- M1s_pairwise %>%
  dplyr::filter(contrast != "sensors - after") %>%
  dplyr::mutate(condition = case_when(
    grepl("sensors", contrast) ~ "With\nSensors",
    grepl("after", contrast) ~ "After\nSensors",
  ),
  sig = ifelse(p.value < alpha_level, "*", "n.s."))

```

### Plot
```{r, warning = F, message = F}
M1s_plotData_mainEffects <- M1s_model |>
  sjPlot::plot_model(type = "int") %>%
  .[["data"]] |>
  as.data.frame() |>
  dplyr::mutate(condition = factor(
    x,
    levels = c(1, 2, 3),
    labels = c("Before\nSensors", "With\nSensors", "After\nSensors")
  )) %>%
  base::merge(.,
              M1s_sigContrasts %>%
                dplyr::select(group, condition, sig),
              all = T)

M1s_plotData <- M1s_modelData |>
  dplyr::mutate(time_point = factor(
    time_point,
    levels = c("before", "sensors", "after"),
    labels = c("Before\nSensors", "With\nSensors", "After\nSensors")
  ))


M1s_plot_summary <- M1s_plotData |>
  ggplot() +
  aes(
    x = time_point,
    y = M1,
    color = group,
    group = speaker_id,
    shape = sex
  ) +
  geom_line(position = position_jitter(width = .15, seed = 1), alpha = .1) +
  geom_point(position = position_jitter(width = .15, seed = 1)) +
  theme_classic() +
  labs(x = NULL,
       y = "M1 (kHz)",
       subtitle = "Summary Data") +
  guides(color = guide_legend(title = "Group"),
         shape = guide_legend(title = "Sex")) +
  scale_color_manual(values = c(my_pal[1], my_pal[2])) +
  theme(legend.position = "bottom", aspect.ratio = 1)

M1s_plot_RQ1 <- M1s_plotData |>
  dplyr::filter(time_point != "After\nSensors") |>
  ggplot() +
  aes(
    x = time_point,
    y = M1,
    color = group,
    group = speaker_id,
    shape = sex
  ) +
  geom_line(
    # position = position_jitter(width = .1, seed = 1),
    alpha = .1, show.legend = FALSE) +
  # geom_point(position = position_jitter(width = .1, seed = 1), alpha = .2) +
  geom_line(
    data = M1s_plotData_mainEffects |>
      dplyr::filter(condition != "After\nSensors"),
    aes(
      x = condition,
      y = predicted,
      group = group,
      color = group
    ),
    linewidth = 1,
    inherit.aes = F,
    show.legend = FALSE
  ) +
  # Adding the significance labels
  ggrepel::geom_text_repel(
    data = M1s_plotData_mainEffects |>
      dplyr::filter(condition != "After\nSensors"),
    aes(
      x = condition,
      y = predicted,
      color = group,
      group = group,
      label = sig
    ),
    position = position_nudge(x = .1),
    hjust = 0,
    box.padding = 0,
    direction = "y",
    inherit.aes = F,
    show.legend = FALSE,
    seed = 1
  ) +
  theme_classic() +
  labs(x = NULL, y = "M1 (kHz)", subtitle = "Research Question 1:\nSensor Effects") +
  guides(color = guide_legend(title = "Group"),
         shape = guide_legend(title = "Sex")) +
  scale_color_manual(values = c(my_pal[1], my_pal[2])) +
  theme(legend.position = "bottom", aspect.ratio = 1)

M1s_plot_RQ2 <- M1s_plotData |>
  dplyr::filter(time_point != "With\nSensors") |>
  ggplot() +
  aes(
    x = time_point,
    y = M1,
    color = group,
    group = speaker_id,
    shape = sex
  ) +
  geom_line(#position = position_jitter(width = .1, seed = 1),
    alpha = .1, show.legend = FALSE) +
  #geom_point(position = position_jitter(width = .1, seed = 1), alpha = .2) +
  geom_line(
    data = M1s_plotData_mainEffects |>
      dplyr::filter(condition != "With\nSensors"),
    aes(
      x = condition,
      y = predicted,
      group = group,
      color = group
    ),
    linewidth = 1,
    inherit.aes = F,
    show.legend = FALSE
  ) +
  # Adding the significance labels
  ggrepel::geom_text_repel(
    data = M1s_plotData_mainEffects |>
      dplyr::filter(condition != "With\nSensors"),
    aes(
      x = condition,
      y = predicted,
      color = group,
      group = group,
      label = sig
    ),
    position = position_nudge(x = .1),
    hjust = 0,
    box.padding = 0,
    direction = "y",
    inherit.aes = F,
    show.legend = FALSE,
    seed = 1
  ) +
  theme_classic() +
  labs(x = NULL, y = "M1 (kHz)", subtitle = "Research Question 2:\nPost-adaptation Effects") +
  guides(color = guide_legend(title = "Group"),
         shape = guide_legend(title = "Sex")) +
  scale_color_manual(values = c(my_pal[1], my_pal[2])) +
  theme(legend.position = "bottom", aspect.ratio = 1)


M1s_plot <- (M1s_plot_summary | M1s_plot_RQ1 | M1s_plot_RQ2) +
  plot_annotation('M1 for /s/') +
  patchwork::plot_layout(guides = "collect") &
  theme(legend.position='bottom')
M1s_plot

```

### Saving Data
Saving the data and cleaning up the environment.
```{r}
workingData_M1s <- list(
  modelData = M1s_modelData,
  pairwise = M1s_pairwise,
  pairwiseES = M1s_pairwiseES,
  plotData = M1s_plotData,
  plotData_mainEffects = M1s_plotData_mainEffects,
  sigContrasts = M1s_sigContrasts,
  emm = M1s_emm,
  model = M1s_model,
  plot = M1s_plot,
  plot_RQ1 = M1s_plot_RQ1,
  plot_RQ2 = M1s_plot_RQ2,
  plot_summary = M1s_plot_summary
)

rm(
  M1s_modelData,
  M1s_pairwise,
  M1s_pairwiseES,
  M1s_plotData,
  M1s_plotData_mainEffects,
  M1s_sigContrasts,
  M1s_emm,
  M1s_model,
  M1s_plot,
  M1s_plot_RQ1,
  M1s_plot_RQ2,
  M1s_plot_summary
)

base::saveRDS(workingData_M1s,
              file = "Data/workingData/data_M1s.RDS")
```
## /Êƒ/
Descriptive results for M1 and M2 for /Êƒ/ or "sh" are shown below. The PD speakers appear to have a lower M1 values overall. However, both groups appear to have lower M1 values with sensors compared to before and after sensors. M2 appears to increase slightly with sensors for both PD and control speakers.

### Descriptives
```{r, warning = F, message = F}

moment_mod <- moment_mod |>
  dplyr::filter(seg_type == "initial")

moment_mod |>
  dplyr::filter(consonant == "/Êƒ/") |>
  dplyr::select(c(group, time_point, M1, M2)) |>
  tbl_strata(
    strata = group,
    ~.x |>
      tbl_summary(
        by = time_point,
        statistic = list(all_continuous() ~ c("{mean} ({sd})")),
        digits = all_continuous() ~ 2,
        label = list(M1 ~ "M1 /Êƒ/",
                     M2 ~ "M2 /Êƒ/")
      ))


```

### Model
A linear mixed effects model for M1 was conducted for /s/ to examine changes across the three time points (before, sensors, after) for the two speaker groups (control and PD). M1 significantly decreased with sensor placement and the PD group had an overall lower M1 values. 

```{r, warning = F, message = F}

M1sh_modelData <- moment_mod |>
  dplyr::filter(consonant == "/Êƒ/")

hist(M1sh_modelData$M1)
performance::check_distribution(M1sh_modelData$M1)

M1sh_model <- lmerTest::lmer(M1 ~ time_point * group + sex + age + (1 | speaker_id), data = M1sh_modelData)

summary(M1sh_model)
performance::check_heteroscedasticity(M1sh_model)
performance::check_normality(M1sh_model) # non-normal, but q-q plots look fine. Heteroscedasticity may be more important
performance::check_model(M1sh_model)
performance::check_collinearity(M1sh_model)


sjPlot::tab_model(
  M1sh_model,
  pred.labels = c(
    "Intercept",
    "Time Point [Sensors]",
    "Time Point [After]",
    "Group [PD]",
    "Sex [Female]",
    "Age",
    "Time Point [Sensors] * Group [PD]",
    "Time Point [After] * Group [PD]"
  ),
  order.terms = c(1, 4, 5, 6, 2, 7, 3, 8),
  dv.labels = "M1 /s/"
)
```

#### Effect Size

The partial eta-squared effect sizes show very small effects for the main effects of time point and group as well as their interaction.

```{r}

effectsize::eta_squared(M1sh_model, alternative = "two.sided")

```

#### Pairwise Comparisons

```{r, warning = F, message = F}

M1sh_emm <- emmeans(M1sh_model, specs = pairwise ~ time_point | group)

# Pairwise comparisons
M1sh_pairwise <- M1sh_emm$contrasts |>
  as.data.frame()

M1sh_pairwise |>
  gt::gt() |>
  fmt_number(decimals = 4) |>
  gt::tab_style(
    style = list(cell_text(weight = "bold")),
    locations = cells_body(columns = estimate:p.value, rows = p.value <= alpha_level)
    ) |>
  gt::tab_header(
    title = "Pairwise Comparisons"
  )

# Effect sizes for the pairwise comparisons
M1sh_pairwiseES <- emmeans::eff_size(
  M1sh_emm,
  sigma = sigma(M1sh_model),
  edf = df.residual(M1sh_model)
) |>
  as.data.frame() |>
  janitor::clean_names() |>
  dplyr::mutate(
    contrast = str_replace_all(contrast, "\\*|\\(|\\)", ""),
    contrast = gsub("before", "Before", contrast),
    contrast = gsub("sensors", "Sensors", contrast),
    contrast = gsub("after", "After", contrast),
  ) |>
  dplyr::left_join(
    M1sh_pairwise |>
      dplyr::mutate(
        contrast = gsub("before", "Before", contrast),
        contrast = gsub("sensors", "Sensors", contrast),
        contrast = gsub("after", "After", contrast)
      ) |>
      dplyr::select(p_value = p.value, contrast, group),
    by = join_by(contrast == contrast, group == group)
  ) 

M1sh_pairwiseES |>
  gt() |>
  fmt_number(decimals = 4) |>
  gt::tab_style(
    style = list(cell_text(weight = "bold")),
    locations = cells_body(columns = effect_size:p_value, rows = p_value <= alpha_level)
    ) |>
  gt::tab_header(
    title = "Pairwise Effect Sizes"
  )

# Creating a data frame to be used for the annotation of sig effects in the plots
M1sh_sigContrasts <- M1sh_pairwise %>%
  dplyr::filter(contrast != "sensors - after") %>%
  dplyr::mutate(condition = case_when(
    grepl("sensors", contrast) ~ "With\nSensors",
    grepl("after", contrast) ~ "After\nSensors",
  ),
  sig = ifelse(p.value < alpha_level, "*", "n.s."))

```

### Plot
```{r, warning = F, message = F}
M1sh_plotData_mainEffects <- M1sh_model |>
  sjPlot::plot_model(type = "int") %>%
  .[["data"]] |>
  as.data.frame() |>
  dplyr::mutate(condition = factor(
    x,
    levels = c(1, 2, 3),
    labels = c("Before\nSensors", "With\nSensors", "After\nSensors")
  )) %>%
  base::merge(.,
              M1sh_sigContrasts %>%
                dplyr::select(group, condition, sig),
              all = T)

M1sh_plotData <- M1sh_modelData |>
  dplyr::mutate(time_point = factor(
    time_point,
    levels = c("before", "sensors", "after"),
    labels = c("Before\nSensors", "With\nSensors", "After\nSensors")
  ))


M1sh_plot_summary <- M1sh_plotData |>
  ggplot() +
  aes(
    x = time_point,
    y = M1,
    color = group,
    group = speaker_id,
    shape = sex
  ) +
  geom_line(position = position_jitter(width = .15, seed = 1), alpha = .1) +
  geom_point(position = position_jitter(width = .15, seed = 1)) +
  theme_classic() +
  labs(x = NULL,
       y = "M1 (kHz)",
       subtitle = "Summary Data") +
  guides(color = guide_legend(title = "Group"),
         shape = guide_legend(title = "Sex")) +
  scale_color_manual(values = c(my_pal[1], my_pal[2])) +
  theme(legend.position = "bottom", aspect.ratio = 1)

M1sh_plot_RQ1 <- M1sh_plotData |>
  dplyr::filter(time_point != "After\nSensors") |>
  ggplot() +
  aes(
    x = time_point,
    y = M1,
    color = group,
    group = speaker_id,
    shape = sex
  ) +
  geom_line(
    # position = position_jitter(width = .1, seed = 1),
    alpha = .1, show.legend = FALSE) +
  # geom_point(position = position_jitter(width = .1, seed = 1), alpha = .2) +
  geom_line(
    data = M1sh_plotData_mainEffects |>
      dplyr::filter(condition != "After\nSensors"),
    aes(
      x = condition,
      y = predicted,
      group = group,
      color = group
    ),
    linewidth = 1,
    inherit.aes = F,
    show.legend = FALSE
  ) +
  # Adding the significance labels
  ggrepel::geom_text_repel(
    data = M1sh_plotData_mainEffects |>
      dplyr::filter(condition != "After\nSensors"),
    aes(
      x = condition,
      y = predicted,
      color = group,
      group = group,
      label = sig
    ),
    position = position_nudge(x = .1),
    hjust = 0,
    box.padding = 0,
    direction = "y",
    inherit.aes = F,
    show.legend = FALSE,
    seed = 1
  ) +
  theme_classic() +
  labs(x = NULL, y = "M1 (kHz)", subtitle = "Research Question 1:\nSensor Effects") +
  guides(color = guide_legend(title = "Group"),
         shape = guide_legend(title = "Sex")) +
  scale_color_manual(values = c(my_pal[1], my_pal[2])) +
  theme(legend.position = "bottom", aspect.ratio = 1)

M1sh_plot_RQ2 <- M1sh_plotData |>
  dplyr::filter(time_point != "With\nSensors") |>
  ggplot() +
  aes(
    x = time_point,
    y = M1,
    color = group,
    group = speaker_id,
    shape = sex
  ) +
  geom_line(#position = position_jitter(width = .1, seed = 1),
    alpha = .1, show.legend = FALSE) +
  #geom_point(position = position_jitter(width = .1, seed = 1), alpha = .2) +
  geom_line(
    data = M1sh_plotData_mainEffects |>
      dplyr::filter(condition != "With\nSensors"),
    aes(
      x = condition,
      y = predicted,
      group = group,
      color = group
    ),
    linewidth = 1,
    inherit.aes = F,
    show.legend = FALSE
  ) +
  # Adding the significance labels
  ggrepel::geom_text_repel(
    data = M1sh_plotData_mainEffects |>
      dplyr::filter(condition != "With\nSensors"),
    aes(
      x = condition,
      y = predicted,
      color = group,
      group = group,
      label = sig
    ),
    position = position_nudge(x = .1),
    hjust = 0,
    box.padding = 0,
    direction = "y",
    inherit.aes = F,
    show.legend = FALSE,
    seed = 1
  ) +
  theme_classic() +
  labs(x = NULL, y = "M1 (kHz)", subtitle = "Research Question 2:\nPost-adaptation Effects") +
  guides(color = guide_legend(title = "Group"),
         shape = guide_legend(title = "Sex")) +
  scale_color_manual(values = c(my_pal[1], my_pal[2])) +
  theme(legend.position = "bottom", aspect.ratio = 1)


M1sh_plot <- (M1sh_plot_summary | M1sh_plot_RQ1 | M1sh_plot_RQ2) +
  plot_annotation('M1 for /Êƒ/') +
  patchwork::plot_layout(guides = "collect") &
  theme(legend.position='bottom')
M1sh_plot

```

### Saving Data
Saving the data and cleaning up the environment.
```{r}
workingData_M1sh <- list(
  modelData = M1sh_modelData,
  pairwise = M1sh_pairwise,
  pairwiseES = M1sh_pairwiseES,
  plotData = M1sh_plotData,
  plotData_mainEffects = M1sh_plotData_mainEffects,
  sigContrasts = M1sh_sigContrasts,
  emm = M1sh_emm,
  model = M1sh_model,
  plot = M1sh_plot,
  plot_RQ1 = M1sh_plot_RQ1,
  plot_RQ2 = M1sh_plot_RQ2,
  plot_summary = M1sh_plot_summary
)

rm(
  M1sh_modelData,
  M1sh_pairwise,
  M1sh_pairwiseES,
  M1sh_plotData,
  M1sh_plotData_mainEffects,
  M1sh_sigContrasts,
  M1sh_emm,
  M1sh_model,
  M1sh_plot,
  M1sh_plot_RQ1,
  M1sh_plot_RQ2,
  M1sh_plot_summary
)

base::saveRDS(workingData_M1sh,
              file = "Data/workingData/data_M1sh.RDS")
```

## M1 Table
```{r}
sjPlot::tab_model(
  workingData_M1s$model,
  workingData_M1sh$model,
  pred.labels = c(
    "Intercept",
    "Time Point [Sensors]",
    "Time Point [After]",
    "Group [PD]",
    "Sex [Female]",
    "Age",
    "Time Point [Sensors] * Group [PD]",
    "Time Point [After] * Group [PD]"
  ),
  order.terms = c(1, 4, 5, 6, 2, 7, 3, 8),
  dv.labels = c("M1 for /s/", "M1 for /Êƒ/"),
  file = "Tables/T5_M1.html"
)
```

# M2
## Reliability

Interrater Reliability
```{r, warning = F, message = F}

moment_mod <- consonants |>
  dplyr::select(speaker_id, group, sex, age, time_point, seg_type, consonant, m1, m2) |>
  dplyr::group_by(speaker_id, time_point, consonant, seg_type) |>
  dplyr::summarize(M2 = mean(m1), M2 = mean(m2)) |>
  dplyr::ungroup() |>
  dplyr::left_join(speakers, by = "speaker_id")
  

M2_rel <- moment_mod|>
  dplyr::select(speaker_id, group, sex, age, time_point, seg_type, consonant, M2) |>
  tidyr::pivot_wider(names_from = seg_type,
                     values_from = M2)


M2_inter <- M2_rel |>
  dplyr::select(-intrarater) |>
  dplyr::filter(!is.na(interrater))

cor.test(M2_inter$initial, M2_inter$interrater, method = "pearson", use = "complete.obs")

```

Intrarater Reliability
```{r, warning = F, message = F}

M2_intra <- M2_rel |>
  dplyr::select(-interrater) |>
  dplyr::filter(!is.na(intrarater))

cor.test(M2_intra$initial, M2_intra$intrarater, method = "pearson", use = "complete.obs")

```

```{r, echo = F, message = F, warning = F}

rm(M2_inter, M2_inter, M2_intra, M2_intra, M2_rel, M2_rel)

```

## /s/
Descriptive results for M2 and M2 for /s/ are shown below. The PD speakers appear to have a lower M2 values overall. However, both groups appear to have lower M2 values with sensors compared to before and after sensors. M2 appears to increase slightly with sensors for both PD and control speakers.

### Descriptives
```{r, warning = F, message = F}

moment_mod <- moment_mod |>
  dplyr::filter(seg_type == "initial")

moment_mod |>
  dplyr::filter(consonant == "/s/") |>
  dplyr::select(c(group, time_point, M2, M2)) |>
  tbl_strata(
    strata = group,
    ~.x |>
      tbl_summary(
        by = time_point,
        statistic = list(all_continuous() ~ c("{mean} ({sd})")),
        digits = all_continuous() ~ 2,
        label = list(M2 ~ "M2 /s/",
                     M2 ~ "M2 /s/")
      ))


```

### Model
A linear mixed effects model for M2 was conducted for /s/ to examine changes across the three time points (before, sensors, after) for the two speaker groups (control and PD). M2 significantly decreased with sensor placement and the PD group had an overall lower M2 values. 

```{r, warning = F, message = F}

M2s_modelData <- moment_mod |>
  dplyr::filter(consonant == "/s/")

hist(M2s_modelData$M2)
performance::check_distribution(M2s_modelData$M2)

M2s_model <- lmerTest::lmer(M2 ~ time_point * group + sex + age + (1 | speaker_id), data = M2s_modelData)

summary(M2s_model)
performance::check_heteroscedasticity(M2s_model)
performance::check_normality(M2s_model)
performance::check_collinearity(M2s_model)


sjPlot::tab_model(
  M2s_model,
  pred.labels = c(
    "Intercept",
    "Time Point [Sensors]",
    "Time Point [After]",
    "Group [PD]",
    "Sex [Female]",
    "Age",
    "Time Point [Sensors] * Group [PD]",
    "Time Point [After] * Group [PD]"
  ),
  order.terms = c(1, 4, 5, 6, 2, 7, 3, 8),
  dv.labels = "M2 /s/"
)
```

#### Effect Size

The partial eta-squared effect sizes show very small effects for the main effects of time point and group as well as their interaction.

```{r}

effectsize::eta_squared(M2s_model, alternative = "two.sided")

```

#### Pairwise Comparisons

```{r, warning = F, message = F}

M2s_emm <- emmeans(M2s_model, specs = pairwise ~ time_point | group)

# Pairwise comparisons
M2s_pairwise <- M2s_emm$contrasts |>
  as.data.frame()

M2s_pairwise |>
  gt::gt() |>
  fmt_number(decimals = 4) |>
  gt::tab_style(
    style = list(cell_text(weight = "bold")),
    locations = cells_body(columns = estimate:p.value, rows = p.value <= alpha_level)
    ) |>
  gt::tab_header(
    title = "Pairwise Comparisons"
  )

# Effect sizes for the pairwise comparisons
M2s_pairwiseES <- emmeans::eff_size(
  M2s_emm,
  sigma = sigma(M2s_model),
  edf = df.residual(M2s_model)
) |>
  as.data.frame() |>
  janitor::clean_names() |>
  dplyr::mutate(
    contrast = str_replace_all(contrast, "\\*|\\(|\\)", ""),
    contrast = gsub("before", "Before", contrast),
    contrast = gsub("sensors", "Sensors", contrast),
    contrast = gsub("after", "After", contrast),
  ) |>
  dplyr::left_join(
    M2s_pairwise |>
      dplyr::mutate(
        contrast = gsub("before", "Before", contrast),
        contrast = gsub("sensors", "Sensors", contrast),
        contrast = gsub("after", "After", contrast)
      ) |>
      dplyr::select(p_value = p.value, contrast, group),
    by = join_by(contrast == contrast, group == group)
  ) 

M2s_pairwiseES |>
  gt() |>
  fmt_number(decimals = 4) |>
  gt::tab_style(
    style = list(cell_text(weight = "bold")),
    locations = cells_body(columns = effect_size:p_value, rows = p_value <= alpha_level)
    ) |>
  gt::tab_header(
    title = "Pairwise Effect Sizes"
  )

# Creating a data frame to be used for the annotation of sig effects in the plots
M2s_sigContrasts <- M2s_pairwise %>%
  dplyr::filter(contrast != "sensors - after") %>%
  dplyr::mutate(condition = case_when(
    grepl("sensors", contrast) ~ "With\nSensors",
    grepl("after", contrast) ~ "After\nSensors",
  ),
  sig = ifelse(p.value < alpha_level, "*", "n.s."))

```

### Plot
```{r, warning = F, message = F}
M2s_plotData_mainEffects <- M2s_model |>
  sjPlot::plot_model(type = "int") %>%
  .[["data"]] |>
  as.data.frame() |>
  dplyr::mutate(condition = factor(
    x,
    levels = c(1, 2, 3),
    labels = c("Before\nSensors", "With\nSensors", "After\nSensors")
  )) %>%
  base::merge(.,
              M2s_sigContrasts %>%
                dplyr::select(group, condition, sig),
              all = T)

M2s_plotData <- M2s_modelData |>
  dplyr::mutate(time_point = factor(
    time_point,
    levels = c("before", "sensors", "after"),
    labels = c("Before\nSensors", "With\nSensors", "After\nSensors")
  ))


M2s_plot_summary <- M2s_plotData |>
  ggplot() +
  aes(
    x = time_point,
    y = M2,
    color = group,
    group = speaker_id,
    shape = sex
  ) +
  geom_line(position = position_jitter(width = .15, seed = 1), alpha = .1) +
  geom_point(position = position_jitter(width = .15, seed = 1)) +
  theme_classic() +
  labs(x = NULL,
       y = "M2 (kHz)",
       subtitle = "Summary Data") +
  guides(color = guide_legend(title = "Group"),
         shape = guide_legend(title = "Sex")) +
  scale_color_manual(values = c(my_pal[1], my_pal[2])) +
  theme(legend.position = "bottom", aspect.ratio = 1)

M2s_plot_RQ1 <- M2s_plotData |>
  dplyr::filter(time_point != "After\nSensors") |>
  ggplot() +
  aes(
    x = time_point,
    y = M2,
    color = group,
    group = speaker_id,
    shape = sex
  ) +
  geom_line(
    # position = position_jitter(width = .1, seed = 1),
    alpha = .1, show.legend = FALSE) +
  # geom_point(position = position_jitter(width = .1, seed = 1), alpha = .2) +
  geom_line(
    data = M2s_plotData_mainEffects |>
      dplyr::filter(condition != "After\nSensors"),
    aes(
      x = condition,
      y = predicted,
      group = group,
      color = group
    ),
    linewidth = 1,
    inherit.aes = F,
    show.legend = FALSE
  ) +
  # Adding the significance labels
  ggrepel::geom_text_repel(
    data = M2s_plotData_mainEffects |>
      dplyr::filter(condition != "After\nSensors"),
    aes(
      x = condition,
      y = predicted,
      color = group,
      group = group,
      label = sig
    ),
    position = position_nudge(x = .1),
    hjust = 0,
    box.padding = 0,
    direction = "y",
    inherit.aes = F,
    show.legend = FALSE,
    seed = 1
  ) +
  theme_classic() +
  labs(x = NULL, y = "M2 (kHz)", subtitle = "Research Question 1:\nSensor Effects") +
  guides(color = guide_legend(title = "Group"),
         shape = guide_legend(title = "Sex")) +
  scale_color_manual(values = c(my_pal[1], my_pal[2])) +
  theme(legend.position = "bottom", aspect.ratio = 1)

M2s_plot_RQ2 <- M2s_plotData |>
  dplyr::filter(time_point != "With\nSensors") |>
  ggplot() +
  aes(
    x = time_point,
    y = M2,
    color = group,
    group = speaker_id,
    shape = sex
  ) +
  geom_line(#position = position_jitter(width = .1, seed = 1),
    alpha = .1, show.legend = FALSE) +
  #geom_point(position = position_jitter(width = .1, seed = 1), alpha = .2) +
  geom_line(
    data = M2s_plotData_mainEffects |>
      dplyr::filter(condition != "With\nSensors"),
    aes(
      x = condition,
      y = predicted,
      group = group,
      color = group
    ),
    linewidth = 1,
    inherit.aes = F,
    show.legend = FALSE
  ) +
  # Adding the significance labels
  ggrepel::geom_text_repel(
    data = M2s_plotData_mainEffects |>
      dplyr::filter(condition != "With\nSensors"),
    aes(
      x = condition,
      y = predicted,
      color = group,
      group = group,
      label = sig
    ),
    position = position_nudge(x = .1),
    hjust = 0,
    box.padding = 0,
    direction = "y",
    inherit.aes = F,
    show.legend = FALSE,
    seed = 1
  ) +
  theme_classic() +
  labs(x = NULL, y = "M2 (kHz)", subtitle = "Research Question 2:\nPost-adaptation Effects") +
  guides(color = guide_legend(title = "Group"),
         shape = guide_legend(title = "Sex")) +
  scale_color_manual(values = c(my_pal[1], my_pal[2])) +
  theme(legend.position = "bottom", aspect.ratio = 1)


M2s_plot <- (M2s_plot_summary | M2s_plot_RQ1 | M2s_plot_RQ2) +
  plot_annotation('M2 for /s/') +
  patchwork::plot_layout(guides = "collect") &
  theme(legend.position='bottom')
M2s_plot

#ggsave(plot = M2s_plot,
#       file = "Figures/F2_M2s.png",
#       height = 3.5,
#       width = 6.5,
#       units = "in",
#       scale = 1.2)
```

### Saving Data
Saving the data and cleaning up the environment.
```{r}
workingData_M2s <- list(
  modelData = M2s_modelData,
  pairwise = M2s_pairwise,
  pairwiseES = M2s_pairwiseES,
  plotData = M2s_plotData,
  plotData_mainEffects = M2s_plotData_mainEffects,
  sigContrasts = M2s_sigContrasts,
  emm = M2s_emm,
  model = M2s_model,
  plot = M2s_plot,
  plot_RQ1 = M2s_plot_RQ1,
  plot_RQ2 = M2s_plot_RQ2,
  plot_summary = M2s_plot_summary
)

rm(
  M2s_modelData,
  M2s_pairwise,
  M2s_pairwiseES,
  M2s_plotData,
  M2s_plotData_mainEffects,
  M2s_sigContrasts,
  M2s_emm,
  M2s_model,
  M2s_plot,
  M2s_plot_RQ1,
  M2s_plot_RQ2,
  M2s_plot_summary
)

base::saveRDS(workingData_M2s,
              file = "Data/workingData/data_M2s.RDS")
```

## /Êƒ/
Descriptive results for M2 and M2 for /Êƒ/ or "sh" are shown below. The M2 values for /Êƒ/ are comparable across the three conditions. Both groups have higher M2 values with sensors, comapred to before and after sensors.

### Descriptives
```{r, warning = F, message = F}

moment_mod <- moment_mod |>
  dplyr::filter(seg_type == "initial")

moment_mod |>
  dplyr::filter(consonant == "/Êƒ/") |>
  dplyr::select(c(group, time_point, M2, M2)) |>
  tbl_strata(
    strata = group,
    ~.x |>
      tbl_summary(
        by = time_point,
        statistic = list(all_continuous() ~ c("{mean} ({sd})")),
        digits = all_continuous() ~ 2,
        label = list(M2 ~ "M2 /Êƒ/",
                     M2 ~ "M2 /Êƒ/")
      ))


```

### Model
A linear mixed effects model for M2 was conducted for /s/ to examine changes across the three time points (before, sensors, after) for the two speaker groups (control and PD). M2 significantly decreased with sensor placement and the PD group had an overall lower M2 values. 

```{r, warning = F, message = F}

M2sh_modelData <- moment_mod |>
  dplyr::filter(consonant == "/Êƒ/")

hist(M2sh_modelData$M2)
performance::check_distribution(M2sh_modelData$M2)

M2sh_model <- lmerTest::lmer(M2 ~ time_point * group + sex + age + (1 | speaker_id), data = M2sh_modelData)

summary(M2sh_model)
performance::check_heteroscedasticity(M2sh_model)
performance::check_normality(M2sh_model) # non-normal, but q-q plots look fine. Heteroscedasticity may be more important
performance::check_model(M2sh_model)
performance::check_collinearity(M2sh_model)


sjPlot::tab_model(
  M2sh_model,
  pred.labels = c(
    "Intercept",
    "Time Point [Sensors]",
    "Time Point [After]",
    "Group [PD]",
    "Sex [Female]",
    "Age",
    "Time Point [Sensors] * Group [PD]",
    "Time Point [After] * Group [PD]"
  ),
  order.terms = c(1, 4, 5, 6, 2, 7, 3, 8),
  dv.labels = "M2 /s/"
)
```

#### Effect Size

The partial eta-squared effect sizes show very small effects for the main effects of time point and group as well as their interaction.

```{r}

effectsize::eta_squared(M2sh_model, alternative = "two.sided")

```

#### Pairwise Comparisons

```{r, warning = F, message = F}

M2sh_emm <- emmeans(M2sh_model, specs = pairwise ~ time_point | group)

# Pairwise comparisons
M2sh_pairwise <- M2sh_emm$contrasts |>
  as.data.frame()

M2sh_pairwise |>
  gt::gt() |>
  fmt_number(decimals = 4) |>
  gt::tab_style(
    style = list(cell_text(weight = "bold")),
    locations = cells_body(columns = estimate:p.value, rows = p.value <= alpha_level)
    ) |>
  gt::tab_header(
    title = "Pairwise Comparisons"
  )

# Effect sizes for the pairwise comparisons
M2sh_pairwiseES <- emmeans::eff_size(
  M2sh_emm,
  sigma = sigma(M2sh_model),
  edf = df.residual(M2sh_model)
) |>
  as.data.frame() |>
  janitor::clean_names() |>
  dplyr::mutate(
    contrast = str_replace_all(contrast, "\\*|\\(|\\)", ""),
    contrast = gsub("before", "Before", contrast),
    contrast = gsub("sensors", "Sensors", contrast),
    contrast = gsub("after", "After", contrast),
  ) |>
  dplyr::left_join(
    M2sh_pairwise |>
      dplyr::mutate(
        contrast = gsub("before", "Before", contrast),
        contrast = gsub("sensors", "Sensors", contrast),
        contrast = gsub("after", "After", contrast)
      ) |>
      dplyr::select(p_value = p.value, contrast, group),
    by = join_by(contrast == contrast, group == group)
  ) 

M2sh_pairwiseES |>
  gt() |>
  fmt_number(decimals = 4) |>
  gt::tab_style(
    style = list(cell_text(weight = "bold")),
    locations = cells_body(columns = effect_size:p_value, rows = p_value <= alpha_level)
    ) |>
  gt::tab_header(
    title = "Pairwise Effect Sizes"
  )

# Creating a data frame to be used for the annotation of sig effects in the plots
M2sh_sigContrasts <- M2sh_pairwise %>%
  dplyr::filter(contrast != "sensors - after") %>%
  dplyr::mutate(condition = case_when(
    grepl("sensors", contrast) ~ "With\nSensors",
    grepl("after", contrast) ~ "After\nSensors",
  ),
  sig = ifelse(p.value < alpha_level, "*", "n.s."))

```

### Plot
```{r, warning = F, message = F}
M2sh_plotData_mainEffects <- M2sh_model |>
  sjPlot::plot_model(type = "int") %>%
  .[["data"]] |>
  as.data.frame() |>
  dplyr::mutate(condition = factor(
    x,
    levels = c(1, 2, 3),
    labels = c("Before\nSensors", "With\nSensors", "After\nSensors")
  )) %>%
  base::merge(.,
              M2sh_sigContrasts %>%
                dplyr::select(group, condition, sig),
              all = T)

M2sh_plotData <- M2sh_modelData |>
  dplyr::mutate(time_point = factor(
    time_point,
    levels = c("before", "sensors", "after"),
    labels = c("Before\nSensors", "With\nSensors", "After\nSensors")
  ))


M2sh_plot_summary <- M2sh_plotData |>
  ggplot() +
  aes(
    x = time_point,
    y = M2,
    color = group,
    group = speaker_id,
    shape = sex
  ) +
  geom_line(position = position_jitter(width = .15, seed = 1), alpha = .1) +
  geom_point(position = position_jitter(width = .15, seed = 1)) +
  theme_classic() +
  labs(x = NULL,
       y = "M2 (kHz)",
       subtitle = "Summary Data") +
  guides(color = guide_legend(title = "Group"),
         shape = guide_legend(title = "Sex")) +
  scale_color_manual(values = c(my_pal[1], my_pal[2])) +
  theme(legend.position = "bottom", aspect.ratio = 1)

M2sh_plot_RQ1 <- M2sh_plotData |>
  dplyr::filter(time_point != "After\nSensors") |>
  ggplot() +
  aes(
    x = time_point,
    y = M2,
    color = group,
    group = speaker_id,
    shape = sex
  ) +
  geom_line(
    # position = position_jitter(width = .1, seed = 1),
    alpha = .1, show.legend = FALSE) +
  # geom_point(position = position_jitter(width = .1, seed = 1), alpha = .2) +
  geom_line(
    data = M2sh_plotData_mainEffects |>
      dplyr::filter(condition != "After\nSensors"),
    aes(
      x = condition,
      y = predicted,
      group = group,
      color = group
    ),
    linewidth = 1,
    inherit.aes = F,
    show.legend = FALSE
  ) +
  # Adding the significance labels
  ggrepel::geom_text_repel(
    data = M2sh_plotData_mainEffects |>
      dplyr::filter(condition != "After\nSensors"),
    aes(
      x = condition,
      y = predicted,
      color = group,
      group = group,
      label = sig
    ),
    position = position_nudge(x = .1),
    hjust = 0,
    box.padding = 0,
    direction = "y",
    inherit.aes = F,
    show.legend = FALSE,
    seed = 1
  ) +
  theme_classic() +
  labs(x = NULL, y = "M2 (kHz)", subtitle = "Research Question 1:\nSensor Effects") +
  guides(color = guide_legend(title = "Group"),
         shape = guide_legend(title = "Sex")) +
  scale_color_manual(values = c(my_pal[1], my_pal[2])) +
  theme(legend.position = "bottom", aspect.ratio = 1)

M2sh_plot_RQ2 <- M2sh_plotData |>
  dplyr::filter(time_point != "With\nSensors") |>
  ggplot() +
  aes(
    x = time_point,
    y = M2,
    color = group,
    group = speaker_id,
    shape = sex
  ) +
  geom_line(#position = position_jitter(width = .1, seed = 1),
    alpha = .1, show.legend = FALSE) +
  #geom_point(position = position_jitter(width = .1, seed = 1), alpha = .2) +
  geom_line(
    data = M2sh_plotData_mainEffects |>
      dplyr::filter(condition != "With\nSensors"),
    aes(
      x = condition,
      y = predicted,
      group = group,
      color = group
    ),
    linewidth = 1,
    inherit.aes = F,
    show.legend = FALSE
  ) +
  # Adding the significance labels
  ggrepel::geom_text_repel(
    data = M2sh_plotData_mainEffects |>
      dplyr::filter(condition != "With\nSensors"),
    aes(
      x = condition,
      y = predicted,
      color = group,
      group = group,
      label = sig
    ),
    position = position_nudge(x = .1),
    hjust = 0,
    box.padding = 0,
    direction = "y",
    inherit.aes = F,
    show.legend = FALSE,
    seed = 1
  ) +
  theme_classic() +
  labs(x = NULL, y = "M2 (kHz)", subtitle = "Research Question 2:\nPost-adaptation Effects") +
  guides(color = guide_legend(title = "Group"),
         shape = guide_legend(title = "Sex")) +
  scale_color_manual(values = c(my_pal[1], my_pal[2])) +
  theme(legend.position = "bottom", aspect.ratio = 1)


M2sh_plot <- (M2sh_plot_summary | M2sh_plot_RQ1 | M2sh_plot_RQ2) +
  plot_annotation('M2 for /Êƒ/') +
  patchwork::plot_layout(guides = "collect") &
  theme(legend.position='bottom')
M2sh_plot

#ggsave(plot = M2sh_plot,
#       file = "Figures/F2_M2sh.png",
#       height = 3.5,
#       width = 6.5,
#       units = "in",
#       scale = 1.2)
```

### Saving Data
Saving the data and cleaning up the environment.
```{r}
workingData_M2sh <- list(
  modelData = M2sh_modelData,
  pairwise = M2sh_pairwise,
  pairwiseES = M2sh_pairwiseES,
  plotData = M2sh_plotData,
  plotData_mainEffects = M2sh_plotData_mainEffects,
  sigContrasts = M2sh_sigContrasts,
  emm = M2sh_emm,
  model = M2sh_model,
  plot = M2sh_plot,
  plot_RQ1 = M2sh_plot_RQ1,
  plot_RQ2 = M2sh_plot_RQ2,
  plot_summary = M2sh_plot_summary
)

rm(
  M2sh_modelData,
  M2sh_pairwise,
  M2sh_pairwiseES,
  M2sh_plotData,
  M2sh_plotData_mainEffects,
  M2sh_sigContrasts,
  M2sh_emm,
  M2sh_model,
  M2sh_plot,
  M2sh_plot_RQ1,
  M2sh_plot_RQ2,
  M2sh_plot_summary
)

base::saveRDS(workingData_M2sh,
              file = "Data/workingData/data_M2sh.RDS")
```
## M2 Table
```{r}
sjPlot::tab_model(
  workingData_M2s$model,
  workingData_M2sh$model,
  pred.labels = c(
    "Intercept",
    "Time Point [Sensors]",
    "Time Point [After]",
    "Group [PD]",
    "Sex [Female]",
    "Age",
    "Time Point [Sensors] * Group [PD]",
    "Time Point [After] * Group [PD]"
  ),
  order.terms = c(1, 4, 5, 6, 2, 7, 3, 8),
  dv.labels = c("M2 for /s/", "M2 for /Êƒ/"),
  file = "Tables/T6_M2.html"
)
```

# Perceptual Analyses

## Listener Demographics

The listener demographics are presented below. Listeners were women from 18 to 23 years old.

```{r, warning = F, message = F}

# Loading in Perceptual Data
perceptual_data <- rio::import("Data/Cleaned Data/perceptual_ratings.csv") |>
  dplyr::mutate(counterbalance = as.factor(counterbalance),
                time_point = factor(time_point, levels = c("before", "sensors", "after")),
                reliability = factor(reliability, levels = c("initial", "reliability")),
                rating_type = factor(rating_type, levels = c("intelligibility", "naturalness")))

listener_demo <- rio::import("Data/Cleaned Data/listener_demographics.csv") |>
  dplyr::mutate(english = as.factor(english),
                age = as.numeric(age),
                gender = as.factor(gender),
                race = as.factor(race),
                ethnicity = as.factor(ethnicity))

speakers <- rio::import("Data/Cleaned Data/articulation_rate.csv") |>
  dplyr::select(speaker_id, group, sex, age) |>
  dplyr::distinct()

# Listener Demographics Table
demo_listener_table <- listener_demo |>
  select(-c(listener_id, english)) |>
  tbl_summary(type = list(age ~ "continuous",
                          gender ~ "categorical",
                          race ~ "categorical",
                          ethnicity ~ "categorical"),
              statistic = list(all_continuous() ~ "{mean} ({sd})",
                               all_categorical() ~ "{n} ({p}%)"),
              digits = list(everything() ~ c(2)),
              label = list(age ~ "Age",
                           gender ~ "Gender",
                           race ~ "Race",
                           ethnicity ~ "Ethnicity")) |>
  as_gt()

demo_listener_table

demo_listener_table |>
  gtsave("Tables/listener_demo.html")

rm(demo_listener_table, listener_demo)
```

## Intelligibility

Listeners completed 4 repeated ratings (20%) in order to get intrarater reliability. Pearson Product Moment Correlation Coefficient was used to calculate intrarater reliability. Based on the result below, intrarater reliability was strong for intelligibility ratings.

### Intrarater Reliability

```{r, warning = F, message = F}

Int_initial <- perceptual_data |>
  dplyr::filter(rating_type == "intelligibility") |>
  dplyr::filter(reliability == "initial")

Int_rel <- perceptual_data |>
  dplyr::filter(rating_type == "intelligibility") |>
  dplyr::filter(reliability == "reliability") |>
  dplyr::select(listener_id, speaker_id, time_point, cp_section, rating) |>
  dplyr::rename(rating_rel = rating)

Int <- left_join(Int_initial, Int_rel, by = c("listener_id", "speaker_id", 
                                                   "time_point", "cp_section")) |>
  dplyr::filter(!is.na(rating_rel))

cor.test(Int$rating, Int$rating_rel, method = "pearson", use = "complete.obs")

rm(Int, Int_rel)

```
### Inter-listener Reliability
```{r}
Int_interRel <- Int_initial |>
  dplyr::group_by(speaker_id, time_point) |>
  dplyr::summarize(M = mean(rating),
                   SD = sd(rating)) |>
  ungroup() |>
  dplyr::left_join(speakers, by = "speaker_id")

```


### Descriptives

Descriptive results for intelligibility are presented below. Overall, intelligibility is lower for the PD speakers compared to the control speakers. However, for both groups, intelligibility is lower during sensor placement compared to before and after sensor placement.

```{r, warning = F, message = F}

Int_modelData <- Int_initial |>
  dplyr::group_by(speaker_id, time_point) |>
  dplyr::summarize(Int = mean(rating),
                   Int_sd = sd(rating)) |>
  ungroup() |>
  dplyr::left_join(speakers, by = "speaker_id")

Int_modelData |>
  dplyr::select(group, time_point, Int) |>
  tbl_strata(
    strata = group,
    ~.x |>
      tbl_summary(
        by = time_point,
        statistic = list(all_continuous() ~ c("{mean} ({sd})")),
        digits = all_continuous() ~ 2,
        label = list(Int ~ "Intelligibility")
      ))

rm(Int_initial)
```

### Model
A linear mixed effects model was conducted to evaluate intelligibility changes across the three time points for the two speaker groups. None of the fixed effects in the model were significant. However, there was a trend of decreased intelligibility during sensor placement.

```{r, warning = F, message = F}
hist(Int_modelData$Int)


Int_model <- robustlmm::rlmer(Int ~ time_point*group + sex + age + (1|speaker_id), data = Int_modelData)

summary(Int_model)
performance::check_heteroscedasticity(Int_model)
performance::check_collinearity(Int_model)


sjPlot::tab_model(
  Int_model,
  pred.labels = c(
    "Intercept",
    "Time Point [Sensors]",
    "Time Point [After]",
    "Group [PD]",
    "Sex [Female]",
    "Age",
    "Time Point [Sensors] * Group [PD]",
    "Time Point [After] * Group [PD]"
  ),
  emph.p = FALSE,
  p.style = "numeric_stars",
  p.threshold = c(alpha_level),
  order.terms = c(1, 4, 5, 6, 2, 7, 3, 8),
  dv.labels = "Intelligibility"
)

```


##### Effect Size

Although none of the fixed effects were significant, the partial eta-sqaured values for the model show a large effect for time point. The main effect of group as well as the interaction between group and time point had large and small effects respectively. However, these results should be interpreted with caution since their confidence intervals contain 0.

```{r}
# Cannot calculate eta squared for the Int model
#effectsize::eta_squared(Int_model, alternative = "two.sided")

```

#### Pairwise Comparisons

```{r, warning = F, message = F}

Int_emm <- emmeans(Int_model, specs = pairwise ~ time_point | group)

# Pairwise comparisons
Int_pairwise <- Int_emm$contrasts |>
  as.data.frame()

Int_pairwise |>
  gt::gt() |>
  fmt_number(decimals = 4) |>
  gt::tab_style(
    style = list(cell_text(weight = "bold")),
    locations = cells_body(columns = estimate:p.value, rows = p.value <= alpha_level)
    ) |>
  gt::tab_header(
    title = "Pairwise Comparisons"
  )

# Effect sizes for the pairwise comparisons
Int_pairwiseES <- emmeans::eff_size(
  Int_emm,
  sigma = sigma(Int_model),
  edf = summary(Int_model)[["devcomp"]][["dims"]][["N"]] - summary(Int_model)[["devcomp"]][["dims"]][["p"]] # had to manually calculate residual df for the robust lmm
) |>
  as.data.frame() |>
  janitor::clean_names() |>
  dplyr::mutate(
    contrast = str_replace_all(contrast, "\\*|\\(|\\)", ""),
    contrast = gsub("before", "Before", contrast),
    contrast = gsub("sensors", "Sensors", contrast),
    contrast = gsub("after", "After", contrast),
  ) |>
  dplyr::left_join(
    Int_pairwise |>
      dplyr::mutate(
        contrast = gsub("before", "Before", contrast),
        contrast = gsub("sensors", "Sensors", contrast),
        contrast = gsub("after", "After", contrast)
      ) |>
      dplyr::select(p_value = p.value, contrast, group),
    by = join_by(contrast == contrast, group == group)
  ) 

Int_pairwiseES |>
  gt() |>
  fmt_number(decimals = 4) |>
  gt::tab_style(
    style = list(cell_text(weight = "bold")),
    locations = cells_body(columns = effect_size:p_value, rows = p_value <= alpha_level)
    ) |>
  gt::tab_header(
    title = "Pairwise Effect Sizes"
  )

# Creating a data frame to be used for the annotation of sig effects in the plots
Int_sigContrasts <- Int_pairwise %>%
  dplyr::filter(contrast != "sensors - after") %>%
  dplyr::mutate(condition = case_when(
    grepl("sensors", contrast) ~ "With\nSensors",
    grepl("after", contrast) ~ "After\nSensors",
  ),
  sig = ifelse(p.value < alpha_level, "*", "n.s."))

```
### Plot
```{r, warning = F, message = F}
Int_plotData_mainEffects <- Int_model |>
  sjPlot::plot_model(type = "int") %>%
  .[["data"]] |>
  as.data.frame() |>
  dplyr::mutate(condition = factor(
    x,
    levels = c(1, 2, 3),
    labels = c("Before\nSensors", "With\nSensors", "After\nSensors")
  )) %>%
  base::merge(.,
              Int_sigContrasts %>%
                dplyr::select(group, condition, sig),
              all = T)

Int_plotData <- Int_modelData |>
  dplyr::mutate(time_point = factor(
    time_point,
    levels = c("before", "sensors", "after"),
    labels = c("Before\nSensors", "With\nSensors", "After\nSensors")
  ))


Int_plot_summary <- Int_plotData |>
  ggplot() +
  aes(
    x = time_point,
    y = Int,
    color = group,
    group = speaker_id,
    shape = sex
  ) +
  geom_line(position = position_jitter(width = .15, seed = 1), alpha = .1) +
  geom_point(position = position_jitter(width = .15, seed = 1)) +
  theme_classic() +
  labs(x = NULL,
       y = "Intelligibility Rating (VAS)",
       subtitle = "Summary Data") +
  guides(color = guide_legend(title = "Group"),
         shape = guide_legend(title = "Sex")) +
  scale_color_manual(values = c(my_pal[1], my_pal[2])) +
  theme(legend.position = "bottom", aspect.ratio = 1)

Int_plot_RQ1 <- Int_plotData |>
  dplyr::filter(time_point != "After\nSensors") |>
  ggplot() +
  aes(
    x = time_point,
    y = Int,
    color = group,
    group = speaker_id,
    shape = sex
  ) +
  geom_line(
    # position = position_jitter(width = .1, seed = 1),
    alpha = .1, show.legend = FALSE) +
  # geom_point(position = position_jitter(width = .1, seed = 1), alpha = .2) +
  geom_line(
    data = Int_plotData_mainEffects |>
      dplyr::filter(condition != "After\nSensors"),
    aes(
      x = condition,
      y = predicted,
      group = group,
      color = group
    ),
    linewidth = 1,
    inherit.aes = F,
    show.legend = FALSE
  ) +
  # Adding the significance labels
  ggrepel::geom_text_repel(
    data = Int_plotData_mainEffects |>
      dplyr::filter(condition != "After\nSensors"),
    aes(
      x = condition,
      y = predicted,
      color = group,
      group = group,
      label = sig
    ),
    position = position_nudge(x = .1),
    hjust = 0,
    box.padding = 0,
    direction = "y",
    inherit.aes = F,
    show.legend = FALSE,
    seed = 1
  ) +
  theme_classic() +
  labs(x = NULL, y = "Intelligibility Rating (VAS)", subtitle = "Research Question 1:\nSensor Effects") +
  guides(color = guide_legend(title = "Group"),
         shape = guide_legend(title = "Sex")) +
  scale_color_manual(values = c(my_pal[1], my_pal[2])) +
  theme(legend.position = "bottom", aspect.ratio = 1)

Int_plot_RQ2 <- Int_plotData |>
  dplyr::filter(time_point != "With\nSensors") |>
  ggplot() +
  aes(
    x = time_point,
    y = Int,
    color = group,
    group = speaker_id,
    shape = sex
  ) +
  geom_line(#position = position_jitter(width = .1, seed = 1),
    alpha = .1, show.legend = FALSE) +
  #geom_point(position = position_jitter(width = .1, seed = 1), alpha = .2) +
  geom_line(
    data = Int_plotData_mainEffects |>
      dplyr::filter(condition != "With\nSensors"),
    aes(
      x = condition,
      y = predicted,
      group = group,
      color = group
    ),
    linewidth = 1,
    inherit.aes = F,
    show.legend = FALSE
  ) +
  # Adding the significance labels
  ggrepel::geom_text_repel(
    data = Int_plotData_mainEffects |>
      dplyr::filter(condition != "With\nSensors"),
    aes(
      x = condition,
      y = predicted,
      color = group,
      group = group,
      label = sig
    ),
    position = position_nudge(x = .1),
    hjust = 0,
    box.padding = 0,
    direction = "y",
    inherit.aes = F,
    show.legend = FALSE,
    seed = 1
  ) +
  theme_classic() +
  labs(x = NULL, y = "Intelligibility Rating (VAS)", subtitle = "Research Question 2:\nPost-adaptation Effects") +
  guides(color = guide_legend(title = "Group"),
         shape = guide_legend(title = "Sex")) +
  scale_color_manual(values = c(my_pal[1], my_pal[2])) +
  theme(legend.position = "bottom", aspect.ratio = 1)


Int_plot <- (Int_plot_summary | Int_plot_RQ1 | Int_plot_RQ2) +
  plot_annotation('Intelligibility Ratings') +
  patchwork::plot_layout(guides = "collect") &
  theme(legend.position='bottom')
Int_plot

#ggsave(plot = Int_plot,
#       file = "Figures/F2_Int.png",
#       height = 3.5,
#       width = 6.5,
#       units = "in",
#       scale = 1.2)
```

### Saving Data
Saving the data and cleaning up the environment.
```{r}
workingData_Int <- list(
  modelData = Int_modelData,
  pairwise = Int_pairwise,
  pairwiseES = Int_pairwiseES,
  plotData = Int_plotData,
  plotData_mainEffects = Int_plotData_mainEffects,
  sigContrasts = Int_sigContrasts,
  emm = Int_emm,
  model = Int_model,
  plot = Int_plot,
  plot_RQ1 = Int_plot_RQ1,
  plot_RQ2 = Int_plot_RQ2,
  plot_summary = Int_plot_summary
)

rm(
  Int_modelData,
  Int_pairwise,
  Int_pairwiseES,
  Int_plotData,
  Int_plotData_mainEffects,
  Int_sigContrasts,
  Int_emm,
  Int_model,
  Int_plot,
  Int_plot_RQ1,
  Int_plot_RQ2,
  Int_plot_summary
)

base::saveRDS(workingData_Int,
              file = "Data/workingData/data_Int.RDS")
```
## Naturalness

### Intrarater Reliability

Intrarater reliability was measured using Pearson Product Moment Correlation Coefficient. The results show a moderate-strong reliability.

```{r, warning = F, message = F}

Nat_initial <- perceptual_data |>
  dplyr::filter(rating_type == "naturalness") |>
  dplyr::filter(reliability == "initial")

Nat_rel <- perceptual_data |>
  dplyr::filter(rating_type == "naturalness") |>
  dplyr::filter(reliability == "reliability") |>
  dplyr::select(listener_id, speaker_id, time_point, cp_section, rating) |>
  dplyr::rename(rating_rel = rating)

nat <- left_join(Nat_initial, Nat_rel, by = c("listener_id", "speaker_id", 
                                                   "time_point", "cp_section")) |>
  dplyr::filter(!is.na(rating_rel))

cor.test(nat$rating, nat$rating_rel, method = "pearson", use = "complete.obs")

rm(nat,
   Nat_rel)

```

### Descriptives

Naturalness ratings appear to be lower for both groups compared to intelligility ratings. However, the patterns of results appear to be similar to the intelligibility ratings.

```{r, warning = F, message = F}

Nat_modelData <- Nat_initial |>
  dplyr::group_by(speaker_id, time_point) |>
  dplyr::summarize(Nat = mean(rating),
                   Nat_sd = sd(rating)) |>
  ungroup() |>
  dplyr::left_join(speakers, by = "speaker_id")

Nat_modelData |>
  dplyr::select(group, time_point, Nat) |>
  tbl_strata(
    strata = group,
    ~.x |>
      tbl_summary(
        by = time_point,
        statistic = list(all_continuous() ~ c("{mean} ({sd})")),
        digits = all_continuous() ~ 2,
        label = list(Nat ~ "Naturalness")
      ))

rm(Nat_initial)
```

### Model

A linear effects model was conducted to evaluate how naturalness ratings changed between the three time points (before, sensors, and after) for the two speaker groups (PD and control). The LME results showed that naturalness was significantly lower during sensor placement compared to before sensors and that PD speakers had lower overall naturalness ratings. Naturalness ratings did not significantly differ before and after sensor placement. 

#### Model Summary

```{r, warning = F, message = F}
hist(Nat_modelData$Nat)
performance::check_distribution(Nat_modelData$Nat)

Nat_model <- robustlmm::rlmer(Nat ~ time_point*group + sex + age + (1|speaker_id), data = Nat_modelData)

summary(Nat_model)
#performance::check_model(Nat_model)
#performance::check_heteroscedasticity(Nat_model)
performance::check_collinearity(Nat_model)


sjPlot::tab_model(
  Nat_model,
  pred.labels = c(
    "Intercept",
    "Time Point [Sensors]",
    "Time Point [After]",
    "Group [PD]",
    "Sex [Female]",
    "Age",
    "Time Point [Sensors] * Group [PD]",
    "Time Point [After] * Group [PD]"
  ),
  order.terms = c(1, 4, 5, 6, 2, 7, 3, 8),
  dv.labels = "Naturalness"
)

```

##### Effect Size

Partial eta-squared analyses show large effect sizes for the main effects of time point and group for the naturalness model. A moderate effect size for the interaction was shown. However, this result is likely not important since the confidence interval contains 0.

```{r, message = F, warning = F}

# Cannot calculated eta sqaured for rlmm model
#effectsize::eta_squared(Nat_model, alternative = "two.sided")

```

##### Pairwise Comparisons

```{r, warning = F, message = F}

Nat_emm <- emmeans(Nat_model, specs = pairwise ~ time_point | group)

# Pairwise comparisons
Nat_pairwise <- Nat_emm$contrasts |>
  as.data.frame()

Nat_pairwise |>
  gt::gt() |>
  fmt_number(decimals = 4) |>
  gt::tab_style(
    style = list(cell_text(weight = "bold")),
    locations = cells_body(columns = estimate:p.value, rows = p.value <= alpha_level)
    ) |>
  gt::tab_header(
    title = "Pairwise Comparisons"
  )

# Effect sizes for the pairwise comparisons
Nat_pairwiseES <- emmeans::eff_size(
  Nat_emm,
  sigma = sigma(Nat_model),
  edf = summary(Nat_model)[["devcomp"]][["dims"]][["N"]] - summary(Nat_model)[["devcomp"]][["dims"]][["p"]] # had to manually calculate residual df for the robust lmm
) |>
  as.data.frame() |>
  janitor::clean_names() |>
  dplyr::mutate(
    contrast = str_replace_all(contrast, "\\*|\\(|\\)", ""),
    contrast = gsub("before", "Before", contrast),
    contrast = gsub("sensors", "Sensors", contrast),
    contrast = gsub("after", "After", contrast),
  ) |>
  dplyr::left_join(
    Nat_pairwise |>
      dplyr::mutate(
        contrast = gsub("before", "Before", contrast),
        contrast = gsub("sensors", "Sensors", contrast),
        contrast = gsub("after", "After", contrast)
      ) |>
      dplyr::select(p_value = p.value, contrast, group),
    by = join_by(contrast == contrast, group == group)
  ) 

Nat_pairwiseES |>
  gt() |>
  fmt_number(decimals = 4) |>
  gt::tab_style(
    style = list(cell_text(weight = "bold")),
    locations = cells_body(columns = effect_size:p_value, rows = p_value <= alpha_level)
    ) |>
  gt::tab_header(
    title = "Pairwise Effect Sizes"
  )

# Creating a data frame to be used for the annotation of sig effects in the plots
Nat_sigContrasts <- Nat_pairwise %>%
  dplyr::filter(contrast != "sensors - after") %>%
  dplyr::mutate(condition = case_when(
    grepl("sensors", contrast) ~ "With\nSensors",
    grepl("after", contrast) ~ "After\nSensors",
  ),
  sig = ifelse(p.value < alpha_level, "*", "n.s."))

```

### Plot
```{r, warning = F, message = F}
Nat_plotData_mainEffects <- Nat_model |>
  sjPlot::plot_model(type = "int") %>%
  .[["data"]] |>
  as.data.frame() |>
  dplyr::mutate(condition = factor(
    x,
    levels = c(1, 2, 3),
    labels = c("Before\nSensors", "With\nSensors", "After\nSensors")
  )) %>%
  base::merge(.,
              Nat_sigContrasts %>%
                dplyr::select(group, condition, sig),
              all = T)

Nat_plotData <- Nat_modelData |>
  dplyr::mutate(time_point = factor(
    time_point,
    levels = c("before", "sensors", "after"),
    labels = c("Before\nSensors", "With\nSensors", "After\nSensors")
  ))


Nat_plot_summary <- Nat_plotData |>
  ggplot() +
  aes(
    x = time_point,
    y = Nat,
    color = group,
    group = speaker_id,
    shape = sex
  ) +
  geom_line(position = position_jitter(width = .15, seed = 1), alpha = .1) +
  geom_point(position = position_jitter(width = .15, seed = 1)) +
  theme_classic() +
  labs(x = NULL,
       y = "Naturalness Rating (VAS)",
       subtitle = "Summary Data") +
  guides(color = guide_legend(title = "Group"),
         shape = guide_legend(title = "Sex")) +
  scale_color_manual(values = c(my_pal[1], my_pal[2])) +
  theme(legend.position = "bottom", aspect.ratio = 1)

Nat_plot_RQ1 <- Nat_plotData |>
  dplyr::filter(time_point != "After\nSensors") |>
  ggplot() +
  aes(
    x = time_point,
    y = Nat,
    color = group,
    group = speaker_id,
    shape = sex
  ) +
  geom_line(
    # position = position_jitter(width = .1, seed = 1),
    alpha = .1, show.legend = FALSE) +
  # geom_point(position = position_jitter(width = .1, seed = 1), alpha = .2) +
  geom_line(
    data = Nat_plotData_mainEffects |>
      dplyr::filter(condition != "After\nSensors"),
    aes(
      x = condition,
      y = predicted,
      group = group,
      color = group
    ),
    linewidth = 1,
    inherit.aes = F,
    show.legend = FALSE
  ) +
  # Adding the significance labels
  ggrepel::geom_text_repel(
    data = Nat_plotData_mainEffects |>
      dplyr::filter(condition != "After\nSensors"),
    aes(
      x = condition,
      y = predicted,
      color = group,
      group = group,
      label = sig
    ),
    position = position_nudge(x = .1),
    hjust = 0,
    box.padding = 0,
    direction = "y",
    inherit.aes = F,
    show.legend = FALSE,
    seed = 1
  ) +
  theme_classic() +
  labs(x = NULL, y = "Naturalness Rating (VAS)", subtitle = "Research Question 1:\nSensor Effects") +
  guides(color = guide_legend(title = "Group"),
         shape = guide_legend(title = "Sex")) +
  scale_color_manual(values = c(my_pal[1], my_pal[2])) +
  theme(legend.position = "bottom", aspect.ratio = 1)

Nat_plot_RQ2 <- Nat_plotData |>
  dplyr::filter(time_point != "With\nSensors") |>
  ggplot() +
  aes(
    x = time_point,
    y = Nat,
    color = group,
    group = speaker_id,
    shape = sex
  ) +
  geom_line(#position = position_jitter(width = .1, seed = 1),
    alpha = .1, show.legend = FALSE) +
  #geom_point(position = position_jitter(width = .1, seed = 1), alpha = .2) +
  geom_line(
    data = Nat_plotData_mainEffects |>
      dplyr::filter(condition != "With\nSensors"),
    aes(
      x = condition,
      y = predicted,
      group = group,
      color = group
    ),
    linewidth = 1,
    inherit.aes = F,
    show.legend = FALSE
  ) +
  # Adding the significance labels
  ggrepel::geom_text_repel(
    data = Nat_plotData_mainEffects |>
      dplyr::filter(condition != "With\nSensors"),
    aes(
      x = condition,
      y = predicted,
      color = group,
      group = group,
      label = sig
    ),
    position = position_nudge(x = .1),
    hjust = 0,
    box.padding = 0,
    direction = "y",
    inherit.aes = F,
    show.legend = FALSE,
    seed = 1
  ) +
  theme_classic() +
  labs(x = NULL, y = "Naturalness Rating (VAS)", subtitle = "Research Question 2:\nPost-adaptation Effects") +
  guides(color = guide_legend(title = "Group"),
         shape = guide_legend(title = "Sex")) +
  scale_color_manual(values = c(my_pal[1], my_pal[2])) +
  theme(legend.position = "bottom", aspect.ratio = 1)


Nat_plot <- (Nat_plot_summary | Nat_plot_RQ1 | Nat_plot_RQ2) +
  plot_annotation('Natelligibility Ratings') +
  patchwork::plot_layout(guides = "collect") &
  theme(legend.position='bottom')
Nat_plot

#ggsave(plot = Nat_plot,
#       file = "Figures/F2_Nat.png",
#       height = 3.5,
#       width = 6.5,
#       units = "in",
#       scale = 1.2)
```

### Saving Data
Saving the data and cleaning up the environment.
```{r}
workingData_Nat <- list(
  modelData = Nat_modelData,
  pairwise = Nat_pairwise,
  pairwiseES = Nat_pairwiseES,
  plotData = Nat_plotData,
  plotData_mainEffects = Nat_plotData_mainEffects,
  sigContrasts = Nat_sigContrasts,
  emm = Nat_emm,
  model = Nat_model,
  plot = Nat_plot,
  plot_RQ1 = Nat_plot_RQ1,
  plot_RQ2 = Nat_plot_RQ2,
  plot_summary = Nat_plot_summary
)

rm(
  Nat_modelData,
  Nat_pairwise,
  Nat_pairwiseES,
  Nat_plotData,
  Nat_plotData_mainEffects,
  Nat_sigContrasts,
  Nat_emm,
  Nat_model,
  Nat_plot,
  Nat_plot_RQ1,
  Nat_plot_RQ2,
  Nat_plot_summary
)

base::saveRDS(workingData_Nat,
              file = "Data/workingData/data_Nat.RDS")
```

## Perceptual Table
```{r}
sjPlot::tab_model(
  workingData_Int$model,
  workingData_Nat$model,
  pred.labels = c(
    "Intercept",
    "Time Point [Sensors]",
    "Time Point [After]",
    "Group [PD]",
    "Sex [Female]",
    "Age",
    "Time Point [Sensors] * Group [PD]",
    "Time Point [After] * Group [PD]"
  ),
  order.terms = c(1, 4, 5, 6, 2, 7, 3, 8),
  dv.labels = c("Intelligibility", "Naturalness"),
  file = "Tables/T7_Perceptual Measures.html"
)
```
