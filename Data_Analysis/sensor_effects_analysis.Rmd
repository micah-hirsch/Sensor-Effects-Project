---
title: "Sensor Effects Analysis"
author: "Micah Hirsch"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_float: true
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Purpose

The following report documents the data analysis conducted for the sensor effects project.

All data analyses were conducted using R version 4.3.2.

```{r, echo = F, warning = F, message = F}

# Loading in the needed packages and data
library(rio) # install.packages("rio") 
library(tidyverse) # install.packages("tidyverse")
library(geometry) # install.packages("geometry")
library(patchwork) # install.packages("patchwork")
library(NatParksPalettes) #install.packages("NatParksPalettes")
library(glmmTMB) # install.packages("glmmTMB")
library(emmeans) # install.packages("emmeans")
library(lme4) # install.packages("lme4")
library(lmerTest) # install.packages("lmerTest")
library(gt) # install.packages("gt")
library(gtsummary) # install.packages("gtsummary")
library(sjPlot) # install.packages("sjPlot")
library(ggpubr) # install.packages("ggpubr")
library(effectsize) # install.packages("effectsize")
library(ggsignif) # install.packages("ggsignif")
library(janitor) # install.packages("janitor")
library(snakecase) # install.packages("snakecase")

vowels <- rio::import("Cleaned Data/vowel_measures.csv") |>
  dplyr::mutate(time_point = factor(time_point, levels = c("before", "sensors", "after")),
                group = factor(group, levels = c("Control", "PD")),
                sex = factor(sex, levels = c("Male", "Female")),
                vowel = factor(vowel, levels = c("i", "u", "ae", "a")),
                seg_type = factor(seg_type, levels = c("initial", "intrarater", "interrater")))

consonants <- rio::import("Cleaned Data/consonant_measures.csv") |>
   dplyr::mutate(time_point = factor(time_point, levels = c("before", "sensors", "after")),
                group = factor(group, levels = c("Control", "PD")),
                sex = factor(sex, levels = c("Male", "Female")),
                consonant = factor(consonant, levels = c("s", "sh"), labels = c("/s/", "/ʃ/")),
                seg_type = factor(seg_type, levels = c("initial", "intrarater", "interrater")))

artic_rate <- rio::import("Cleaned Data/articulation_rate.csv") |>
  dplyr::mutate(time_point = factor(time_point, levels = c("before", "sensors", "after")),
                group = factor(group, levels = c("Control", "PD")), 
                sex = factor(sex, levels = c("Male", "Female")),
                phrase = as.factor(phrase),
                seg_type = factor(seg_type, levels = c("initial", "intrarater", "interrater")))

speakers <- artic_rate |>
  dplyr::select(speaker_id, group, sex, age) |>
  dplyr::distinct()

```


# Speaker Demographics

Below is the demographic information for the speakers in this study. Overall, there were more control speakers than speakers with Parkinson's disease. The PD speakers were slightly older than the control speakers (but both groups within 1 SD of each other). There was a higher proportion of female speakers in the control group compared to the PD group.

```{r, message = F, warning = F}

demo_table <- speakers |>
  dplyr::select(-speaker_id) |>
  tbl_summary(
    by = group,
    statistic = list(all_continuous() ~ c("{mean} ({sd})")),
    digits = all_continuous() ~ 2,
    label = list(age ~ "Age",
                 sex ~ "Sex")) |>
  add_overall() |>
  as_gt()

demo_table

demo_table |>
  gtsave("Tables/speaker_demo.html")

```


# Articulation Rate

## Reliability

The audio files were segmented by two different research assistants. Each rater also re-segmented 20% of their own segments. Therefore, Pearson Product-Moment Correlation Coefficients were used to evaluate interrater and intrarater reliability. The results below show that interrater and intrarater reliability for articulation rate was strong.

### Interrater Reliability

```{r, warning = F, message = F}

artic_rate_rel <- artic_rate |>
  tidyr::pivot_wider(names_from = seg_type,
                     values_from = artic_rate)

ar_inter <- artic_rate_rel |>
  dplyr::select(-intrarater) |>
  dplyr::filter(!is.na(interrater))

cor.test(ar_inter$initial, ar_inter$interrater, method = "pearson", use = "complete.obs")

```

### Intrarater Reliability

```{r, warning = F, message = F}

ar_intra <- artic_rate_rel |>
  dplyr::select(-interrater) |>
  dplyr::filter(!is.na(intrarater))

cor.test(ar_intra$initial, ar_intra$intrarater, method = "pearson", use = "complete.obs")

```


```{r, echo = F, warning = F, message = F}

rm(ar_inter, ar_intra, artic_rate_rel, demo_table)

```


## Descriptives

Descriptive statistics for articulation rate across the three time points are shown below. Descriptively, articulation rate is increasing across time points for both speaker groups.

```{r, warning = F, message = F}

ar_mod <- artic_rate |>
  dplyr::filter(seg_type == "initial") |>
  dplyr::group_by(speaker_id, time_point) |>
  dplyr::summarize(artic_rate_m = mean(artic_rate)) |>
  dplyr::left_join(speakers, by = "speaker_id") |>
  ungroup()

ar_mod |>
  dplyr::select(c(group, time_point, artic_rate_m)) |>
  tbl_strata(
    strata = group,
    ~.x |>
      tbl_summary(
        by = time_point,
        statistic = list(all_continuous() ~ c("{mean} ({sd})")),
        digits = all_continuous() ~ 2,
        label = list(artic_rate_m ~ "Articulation Rate")
      ))

```

## Model

We are using linear mixed effects models to test the differences in articulation rate across the three time points (before, sensors, and after) for both speaker groups (control and PD). The model results below indicate an increase in articulation rate after sensor removal compared to before sensor placement. 

### Model Summary

```{r, warning = F, message = F}

ar_model <- lmer(artic_rate_m ~ time_point*group + (1|speaker_id), data = ar_mod)

sjPlot::tab_model(ar_model, pred.labels = c("Intercept", "Time Point [Sensors]", "Time Point [After]",
                                            "Group [PD]", "Time Point [Sensors] * Group [PD]",
                                            "Time Point [After] * Group [PD]"),
                  dv.labels = "Articulation Rate",
                  file = "Tables/artic_rate_model.html")

``` 


#### Model Effect Size

The partial eta-squared values for the articulation rate model are shown below. Based on the results here, the effect of time point is large. The effect sizes for the main effect of group and the interaction between group and time point are small.

```{r, message = F, warning = F}

effectsize::eta_squared(ar_model, alternative = "two.sided")

``` 

### Pairwise Comparisons

We ran pairwise comparisons using the emmeans package. The results below show the significant difference between the before and after time points in the model are primarily driven by the control speakers (this was the only significant contrast).

```{r, warning = F, message = F}

emm_artic_rate <- emmeans(ar_model, specs = pairwise ~ time_point:group)
ar_contrasts <- emm_artic_rate$contrasts |>
  as.data.frame()

ar_contrasts |>
  gt::gt() |>
  fmt_number(decimals = 4)

```

#### Pairwise Effect Sizes

Cohen's d effect sizes were also calculated for these pairwise comparisons. The before and after contrast for the control speaker is significant and has a large effect size. No other comparisons had contrasts that were significant and/or had effect size confidence intervals that do not contain 0.

The plot shown below shows the effect size of each pairwise comparison. The comparisons that are faded have effect size CIs that contain zero, while the bolded contrasts have effect size CIs that do not contain 0. A solid dot indicates the contrast was statistically significant. A hollow dot means the contrast was not statistically significant.

```{r, message = F, warning = F}

my_pal <- c("#550527", "#82B12F", "#FAA613")

ar_contrasts <- ar_contrasts |>
  dplyr::mutate(contrast = gsub("before", "Before", contrast),
                contrast = gsub("sensors", "Sensors", contrast),
                contrast = gsub("after", "After", contrast)) |>
  dplyr::rename(p_value = p.value) |>
  dplyr::select(contrast, p_value)

ar_effect_size <- eff_size(emm_artic_rate, sigma = sigma(ar_model), edf = df.residual(ar_model))|>
  as.data.frame() |>
  janitor::clean_names() |>
  dplyr::mutate(contrast = str_replace_all(contrast, "\\*|\\(|\\)", ""),
                contrast = gsub("before", "Before", contrast),
                contrast = gsub("sensors", "Sensors", contrast),
                contrast = gsub("after", "After", contrast),
                effect = ifelse(lower_cl <= 0 & upper_cl >= 0, 
                             F, T)) |>
  dplyr::left_join(ar_contrasts, by = "contrast") |>
  dplyr::mutate(sig = ifelse(p_value < .05, T, F)) |>
  ggplot() +
  aes(y = contrast,
      x = effect_size,
      color = effect,
      shape = sig,
      alpha = effect) +
  geom_linerange(aes(xmin = lower_cl, xmax = upper_cl), size = 1) +
  geom_point(size = 2.5) +
  geom_vline(xintercept = 0, color = "black", linetype = "dashed") +
  scale_alpha_discrete(range = c(.3, 1), guide = "none") +
  scale_shape_manual(values = c(1, 16), guide = "none") +
  scale_color_manual(values = c("black", my_pal[3])) +
  labs(x = "Cohen's d Effect Size",
       y = "Contrast",
       title =  "Articulation Rate") +
  theme_classic()

ar_effect_size

```


## Plot

### Group Differences

```{r, warning = F, message = F}

model_ar <- ar_model |>
  sjPlot::plot_model(type = "int")

plot_data_ar <- model_ar[["data"]] |>
  as.data.frame() |>
  dplyr::mutate(condition = factor(x, levels= c(1, 2, 3), 
                                   labels = c("Before", "Sensors", "After")))


plot_data_ar |>
  ggplot() +
  aes(x = condition,
      y = predicted,
      color = group,
      group = group) +
  geom_line(position = position_dodge(width = .3),
            alpha = .8) +
  geom_point(size = 2, position = position_dodge(width = .3)) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high),
                position = position_dodge(width = .3),
                width = 0,
                size = 1,
                alpha = .8) +
  labs(x = "Time Point", y = "Articulation Rate (syl/s)") +
  geom_signif(data = data.frame(Group = c("Before", "Sensors", "After")),
              aes(y_position = c(rep(5.5, 3)),
                  xmin = c(1.1, 2.1, 1.1),
                  xmax = c(1.9, 2.9, 2.9),
                  annotations = c(NA, NA, "*"),
                  group = c(1,2,3)),
              vjust = .5,
              color = my_pal[1],
              tip_length = 0,
              manual = T) +
  scale_color_manual(values = c(my_pal[1], my_pal[2])) +
  coord_cartesian(ylim = c(4.4, 5.75)) +
  theme_classic() +
  theme(legend.position = "bottom",
        aspect.ratio = 1)

ggsave("Figures/artic_rate_plot.png")

```


### Individual Speaker Plot

```{r}

ar_mod |>
  ggplot() +
  aes(x = time_point,
      y = artic_rate_m,
      color = group,
      group = speaker_id) +
  geom_line(position = position_dodge(width = .3),
            alpha = .8) +
  #geom_point(size = 2, position = position_dodge(width = .3)) +
  labs(x = "Time Point", y = "Articulation Rate (syl/s)") +
  scale_color_manual(values = c(my_pal[1], my_pal[2])) +
  facet_wrap("group") +
  theme_classic() +
  theme(legend.position = "bottom",
        aspect.ratio = 1)


```


# Vowel Space Area

## Reliability

Similar to articulation rate, Pearson Product Moment Correlation Coefficients were used to assess interrater and intrarater reliability for vowel space area. The results indicate strong interrater and intrarater reliability for VSA.

### Interrater Reliability

```{r, warning = F, message = F}

VSA_coords <- vowels |>
  dplyr::group_by(speaker_id, time_point, vowel, seg_type) |>
  dplyr::summarize(F1 = mean(f1),
                   F2 = mean(f2)) |>
  dplyr::ungroup()

VSA <- VSA_coords |>
  dplyr::group_by(speaker_id, time_point, seg_type) |>
  dplyr::mutate(VSA = (geometry::polyarea(F1, F2))/1000) |> # Converted to kHz
  dplyr::select(!c(vowel, F1, F2)) |>
  dplyr::distinct() |>
  dplyr::left_join(speakers, by = "speaker_id") |>
  ungroup()

VSA_rel <- VSA |>
  tidyr::pivot_wider(names_from = seg_type,
                     values_from = VSA)

VSA_inter <- VSA_rel |>
  dplyr::select(-intrarater) |>
  dplyr::filter(!is.na(interrater))

cor.test(VSA_inter$initial, VSA_inter$interrater, method = "pearson", use = "complete.obs")

```

### Intrarater Reliability

```{r, warning = F, message = F}

VSA_intra <- VSA_rel |>
  dplyr::select(-interrater) |>
  dplyr::filter(!is.na(intrarater))

cor.test(VSA_intra$initial, VSA_intra$intrarater, method = "pearson", use = "complete.obs")

```



```{r, echo = F, warning = F, message = F}

rm(VSA_rel, VSA_intra, VSA_inter, VSA_coords)

```


## Descriptives

The descriptive statistics for VSA are below. Descriptively, VSA decreased during sensor placement for the control speakers and increased for the speakers with PD. VSA during sensor placement and after sensor removal were comparable within each of the the two speaker groups.

```{r, warning = F, message = F}

VSA_mod <- VSA |>
  dplyr::filter(seg_type == "initial")

VSA_mod |>
  dplyr::select(c(group, time_point, VSA)) |>
  tbl_strata(
    strata = group,
    ~.x |>
      tbl_summary(
        by = time_point,
        statistic = list(all_continuous() ~ c("{mean} ({sd})")),
        digits = all_continuous() ~ 2
      ))

```


## Model

A linear mixed effects model was ran to determine the change in VSA between the three time points (before, sensors, and after) for the two speaker groups (control and PD). None of the fixed effects were significant indicating VSA was comparable across the three time points for the two speaker groups.

### Model Summary

```{r, warning = F, message = F}

VSA_model <- lmer(VSA ~ time_point*group + (1|speaker_id), data = VSA_mod)

sjPlot::tab_model(VSA_model, pred.labels = c("Intercept", "Time Point [Sensors]", "Time Point [After]",
                                            "Group [PD]", "Time Point [Sensors] * Group [PD]",
                                            "Time Point [After] * Group [PD]"),
                  dv.labels = "Vowel Space Area",
                  file = "Tables/VSA_model.html")

```


#### Effect Size

The partial eta-squared effect sizes show very small effects for the main effects of time point and group as well as their interaction.

```{r}

effectsize::eta_squared(VSA_model, alternative = "two.sided")

```

## Plot

### Group Differences

```{r, warning = F, message = F}

model_VSA <- VSA_model |>
  sjPlot::plot_model(type = "int")

plot_data_VSA <- model_VSA[["data"]] |>
  as.data.frame() |>
  dplyr::mutate(condition = factor(x, levels= c(1, 2, 3), 
                                   labels = c("Before", "Sensors", "After")))

plot_data_VSA |>
  ggplot() +
  aes(x = condition,
      y = predicted,
      group = group,
      color = group) +
  geom_point(size = 2, position = position_dodge(width = .3)) +
  geom_line(position = position_dodge(width = .3),
            alpha = .8) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high),
                position = position_dodge(width = .3),
                width = 0,
                size = 1,
                alpha = .8) +
  scale_color_manual(values = c(my_pal[1], my_pal[2])) +
  labs(
    x = "Time Point",
    y = bquote('Vowel Space Area '(kHz^2))) +
  theme_classic() +
  theme(legend.position = "bottom",
        aspect.ratio = 1)

ggsave("Figures/VSA_plot.png", plot = last_plot())

```

### Individual Speaker Plot

```{r}

VSA_mod |>
  ggplot() +
  aes(x = time_point,
      y = VSA,
      group = speaker_id,
      color = group) +
  geom_line() +
  scale_color_manual(values = c(my_pal[1], my_pal[2])) +
  labs(
    x = "Time Point",
    y = bquote('Vowel Space Area '(kHz^2))) +
  theme_classic() +
  facet_wrap("group") +
  theme(legend.position = "bottom",
        aspect.ratio = 1)

```


## Exploratory VSA Model

Although we saw an interesting trend in VSA, the model above showed no significant fixed effects of VSA. It is possible that since we are observing an increase in articulation rate across the three time points, that this may impact the results were are seeing in the VSA model. Therefore, we are running an exploratory model for VSA by adding artic_rate as a covariate in the model. Based on the model output below, adding articulation rate as a covariate did not change the model output much.

```{r, warning = F, message = F}

VSA_mod_2 <- dplyr::left_join(VSA_mod, ar_mod, by=c("speaker_id", "time_point", "group", "sex", "age"))

VSA_model_2 <- lmer(VSA ~ time_point*group + artic_rate_m + (1|speaker_id), data = VSA_mod_2)

sjPlot::tab_model(VSA_model_2,
                  pred.labels = c("Intercept", "Time Point [Sensors]", "Time Point [After]",
                                   "Group [PD]", "Articulation Rate", 
                                   "Time Point [Sensors] * Group [PD]",
                                   "Time Point [After] * Group [PD]"),
                  dv.labels = "Vowel Space Area")

```


#### Exploratory Model Effect Size

Again, partial eta-squared values were calculated. All calculated effect sizes are small.

```{r}

effectsize::eta_squared(VSA_model_2, alternative = "two.sided")

```

# Spectral Moment Analysis

## Reliability

Pearson Product Moment Correlation Coefficients were used to determine interrater and intrarater reliability for M1 and M2. The results indicate strong interrater and intrarater reliability.

### Interrater Reliability

#### M1

```{r, warning = F, message = F}

moment_mod <- consonants |>
  dplyr::select(speaker_id, group, sex, age, time_point, seg_type, consonant, m1, m2) |>
  dplyr::group_by(speaker_id, time_point, consonant, seg_type) |>
  dplyr::summarize(M1 = mean(m1), M2 = mean(m2)) |>
  dplyr::ungroup() |>
  dplyr::left_join(speakers, by = "speaker_id")
  

M1_rel <- moment_mod|>
  dplyr::select(speaker_id, group, sex, age, time_point, seg_type, consonant, M1) |>
  tidyr::pivot_wider(names_from = seg_type,
                     values_from = M1)


M1_inter <- M1_rel |>
  dplyr::select(-intrarater) |>
  dplyr::filter(!is.na(interrater))

cor.test(M1_inter$initial, M1_inter$interrater, method = "pearson", use = "complete.obs")

```

#### M2

```{r, warning = F, message = F}

M2_rel <- moment_mod|>
  dplyr::select(speaker_id, group, sex, age, time_point, seg_type, consonant, M2) |>
  tidyr::pivot_wider(names_from = seg_type,
                     values_from = M2)


M2_inter <- M2_rel |>
  dplyr::select(-intrarater) |>
  dplyr::filter(!is.na(interrater))

cor.test(M2_inter$initial, M2_inter$interrater, method = "pearson", use = "complete.obs")

```

### Intrarater

#### M1

```{r, warning = F, message = F}

M1_intra <- M1_rel |>
  dplyr::select(-interrater) |>
  dplyr::filter(!is.na(intrarater))

cor.test(M1_intra$initial, M1_intra$intrarater, method = "pearson", use = "complete.obs")

```

#### M2

```{r, warning = F, message = F}

M2_intra <- M2_rel |>
  dplyr::select(-interrater) |>
  dplyr::filter(!is.na(intrarater))

cor.test(M2_intra$initial, M2_intra$intrarater, method = "pearson", use = "complete.obs")

```

```{r, echo = F, message = F, warning = F}

rm(M1_inter, M2_inter, M1_intra, M2_intra, M2_rel, M1_rel)

```


## Descriptives

### Spectral Moment Coefficient for /s/

Descriptive results for M1 and M2 for /s/ are shown below. The PD speakers appear to have a lower M1 values overall. However, both groups appear to have lower M1 values during sensor placement compared to before and after sensors. M2 appears to increase slightly during sensor placement for both PD and control speakers.

```{r, warning = F, message = F}

moment_mod <- moment_mod |>
  dplyr::filter(seg_type == "initial")

moment_mod |>
  dplyr::filter(consonant == "/s/") |>
  dplyr::select(c(group, time_point, M1, M2)) |>
  tbl_strata(
    strata = group,
    ~.x |>
      tbl_summary(
        by = time_point,
        statistic = list(all_continuous() ~ c("{mean} ({sd})")),
        digits = all_continuous() ~ 2,
        label = list(M1 ~ "M1 /s/",
                     M2 ~ "M2 /s/")
      ))


```

### Spectral Moment Coefficient for /sh/

Descriptive statistics for M1 and M2 for /sh/ are presented below. The M1 and M2 values between the two groups appear to be similar and follow a similar pattern to the results from /s/.

```{r, warning = F, message = F}

moment_mod |>
  dplyr::filter(consonant == "/ʃ/") |>
  dplyr::select(c(group, time_point, M1, M2)) |>
  tbl_strata(
    strata = group,
    ~.x |>
      tbl_summary(
        by = time_point,
        statistic = list(all_continuous() ~ c("{mean} ({sd})")),
        digits = all_continuous() ~ 2,
        label = list(M1 ~ "M1 /ʃ/",
                     M2 ~ "M2 /ʃ/")
      ))

```


## Models

### Spectral Moment Coefficient for /s/

#### M1

A linear mixed effects model for M1 was conducted for /s/ to examine changes across the three time points (before, sensors, after) for the two speaker groups (control and PD). M1 significantly decreased with sensor placement and the PD group had an overall lower M1 values. 

##### Model Summary

```{r, warning = F, message = F}

moment_mod_s <- moment_mod |>
  dplyr::filter(consonant == "/s/")

M1_s_mod <- lmer(M1 ~ time_point*group + (1|speaker_id), data = moment_mod_s)

sjPlot::tab_model(M1_s_mod, pred.labels = c("Intercept", "Time Point [Sensors]", "Time Point [After]",
                                            "Group [PD]", "Time Point [Sensors] * Group [PD]",
                                            "Time Point [After] * Group [PD]"),
                  dv.labels = "M1 /s/")

```

###### Effect Size For Model

Partial eta-squared values were calculated for the M1 /s/ model. The results show a large effect for the main effect of time point and a medium effect for the main effect of group and the interaction between group and time point. However, these latter two effect sizes should be interpreted with caution since their confidence intervals contains 0.

```{r}

effectsize::eta_squared(M1_s_mod, alternative = "two.sided")

```


##### Pairwise Comparisons

Pairwise comparisons were conducted using the emmeans package. These comparisons also showed that the contrast between sensor placement and after placement was significant for the control group in addition to before and during sensor placement.

```{r}

emm_M1_s <- emmeans(M1_s_mod, specs = pairwise ~ time_point:group)
M1_s_contrasts <- emm_M1_s$contrasts |>
  as.data.frame()

M1_s_contrasts |>
  gt::gt() |>
  fmt_number(decimals = 4)

```

###### Pairwise Comparison Effect Sizes

Cohen's D for the pairwise contrasts were also calculated to obtain effect sizes. From the output below, we see large effects for the before and during sensors contrast and during sensors and after sensors contrasts for both the control speakers and PD speakers. Also, there was a large effect size for the contrast between the control and PD speakers before sensor placement.

```{r, message = F, warning = F}

M1_s_contrasts <- M1_s_contrasts |>
  dplyr::mutate(contrast = gsub("before", "Before", contrast),
                contrast = gsub("sensors", "Sensors", contrast),
                contrast = gsub("after", "After", contrast)) |>
  dplyr::rename(p_value = p.value) |>
  dplyr::select(contrast, p_value)

M1_s_effect_size <- eff_size(emm_M1_s, sigma = sigma(M1_s_mod), edf = df.residual(M1_s_mod)) |>
  as.data.frame() |>
  janitor::clean_names() |>
  dplyr::mutate(contrast = str_replace_all(contrast, "\\*|\\(|\\)", ""),
                contrast = gsub("before", "Before", contrast),
                contrast = gsub("sensors", "Sensors", contrast),
                contrast = gsub("after", "After", contrast),
                effect = ifelse(lower_cl <= 0 & upper_cl >= 0, 
                             F, T)) |>
  dplyr::left_join(M1_s_contrasts, by = "contrast") |>
  dplyr::mutate(sig = ifelse(p_value < .05, T, F)) |>
  ggplot() +
  aes(y = contrast,
      x = effect_size,
      shape = sig,
      color = effect,
      alpha = effect) +
  geom_linerange(aes(xmin = lower_cl, xmax = upper_cl), size = 1) +
  geom_point(size = 2.5) +
  geom_vline(xintercept = 0, color = "black", linetype = "dashed") +
  scale_alpha_discrete(range = c(.3, 1), guide = "none") +
  scale_shape_manual(values = c(1, 16), guide = "none") +
  scale_color_manual(values = c("black", my_pal[3])) +
  labs(x = "Cohen's d Effect Size",
       y = "Contrast",
       title =  "M1 /s/") +
  theme_classic()

M1_s_effect_size

```

#### M2

##### Model Summary

None of the fixed effects of the /s/ M2 model were significant.

```{r, warning = F, message = F}


M2_s_mod <- lmer(M2 ~ time_point*group + (1|speaker_id), data = moment_mod_s)
sjPlot::tab_model(M2_s_mod,
                  pred.labels = c("Intercept", "Time Point [Sensors]", "Time Point [After]",
                                            "Group [PD]", "Time Point [Sensors] * Group [PD]",
                                            "Time Point [After] * Group [PD]"),
                  dv.labels = "M2 /s/")

```


###### Effect Size for Model

Although the main effect of time point was not significant in the model, the effect size for time point is large.

```{r, warning = F, message = F}

effectsize::eta_squared(M2_s_mod, alternative = "two.sided")

```
##### Pairwise Comparisons

Because we saw a large partial eta-squared value for time point, we are following this up with pairwise comparisons. As reported below, none of the pairwise contrasts were significant.

```{r, warning = F, message = F}

emm_M2_s <- emmeans(M2_s_mod, specs = pairwise ~ time_point:group)
M2_s_contrasts <- emm_M2_s$contrasts |>
  as.data.frame()

M2_s_contrasts |>
  gt::gt() |>
  fmt_number(decimals = 4)

```

###### Pairwise Comparison Effect Sizes

Although none of the pairwise comparisons were significant, the contrast comparing M1 before and during sensor placement for the PD speakers has a large effect size. However, note the large confidence interval.

```{r, message = F, warning = F}

M2_s_contrasts <- M2_s_contrasts |>
  dplyr::mutate(contrast = gsub("before", "Before", contrast),
                contrast = gsub("sensors", "Sensors", contrast),
                contrast = gsub("after", "After", contrast)) |>
  dplyr::rename(p_value = p.value) |>
  dplyr::select(contrast, p_value)

M2_s_effect_size <- eff_size(emm_M2_s, sigma = sigma(M2_s_mod), edf = df.residual(M2_s_mod)) |>
  as.data.frame() |>
  janitor::clean_names() |>
  dplyr::mutate(contrast = str_replace_all(contrast, "\\*|\\(|\\)", ""),
                contrast = gsub("before", "Before", contrast),
                contrast = gsub("sensors", "Sensors", contrast),
                contrast = gsub("after", "After", contrast),
                effect = ifelse(lower_cl <= 0 & upper_cl >= 0, 
                             F, T)) |>
  dplyr::left_join(M2_s_contrasts, by = "contrast") |>
  dplyr::mutate(sig = ifelse(p_value < .05, T, F)) |>
  ggplot() +
  aes(y = contrast,
      x = effect_size,
      shape = sig,
      color = effect,
      alpha = effect) +
  geom_linerange(aes(xmin = lower_cl, xmax = upper_cl), size = 1) +
  geom_point(size = 2.5) +
  geom_vline(xintercept = 0, color = "black", linetype = "dashed") +
  scale_alpha_discrete(range = c(.3, 1), guide = "none") +
  scale_shape_manual(values = c(1, 16), guide = "none") +
  scale_color_manual(values = c("black", my_pal[3])) +
  labs(x = "Cohen's d Effect Size",
       y = "Contrast",
       title =  "c) M2 /s/") +
  theme_classic()

M2_s_effect_size

```

### Spectral Moment Coefficient for /sh/

#### M1 

##### Model Summary

None of the fixed effects for the LME model for M1 for /sh/ were significant.

```{r, warning = F, message = F}

moment_mod_sh <- moment_mod |>
  dplyr::filter(consonant == "/ʃ/")

M1_sh_mod <- lmer(M1 ~ time_point*group + (1|speaker_id), data = moment_mod_sh)

sjPlot::tab_model(M1_sh_mod, pred.labels = c("Intercept", "Time Point [Sensors]", "Time Point [After]",
                                            "Group [PD]", "Time Point [Sensors] * Group [PD]",
                                            "Time Point [After] * Group [PD]"),
                  dv.labels = "M1 /ʃ/")

```


###### Effect Size for Model

Although none of the fixed effects were significant, partial eta-squared values for the model show a large effect size for time point in this model. The other effect sizes for group and the interaction are small However, their confidence intervals contain 0, so this is unlikely an important outcome.

```{r}

effectsize::eta_squared(M1_sh_mod, alternative = "two.sided")

```

##### Pairwise Comparisons

Since there was a large effect shown in the overall model for time point, we ran pairwise comparisons for the /sh/ M1 model. As shown below, none of the contrasts were significant.

```{r}

emm_M1_sh <- emmeans(M1_sh_mod, specs = pairwise ~ time_point:group)
M1_sh_contrasts <- emm_M1_sh$contrasts |>
  as.data.frame()

M1_sh_contrasts |>
  gt::gt() |>
  fmt_number(decimals = 4)

```

###### Pairwise Comparison Effect Sizes

However, when we conducted Cohen's d analysis to get the pairwise comparisons' effect sizes, we see a relatively large effect for the contrast comparing during sensor placement to after sensor removal for the control speakers.

```{r, message = F, warning = F}

M1_sh_contrasts <- M1_sh_contrasts |>
  dplyr::mutate(contrast = gsub("before", "Before", contrast),
                contrast = gsub("sensors", "Sensors", contrast),
                contrast = gsub("after", "After", contrast)) |>
  dplyr::rename(p_value = p.value) |>
  dplyr::select(contrast, p_value)

M1_sh_effect_size <- eff_size(emm_M1_sh, sigma = sigma(M1_sh_mod), edf = df.residual(M1_sh_mod)) |>
  as.data.frame() |>
  janitor::clean_names() |>
  dplyr::mutate(contrast = str_replace_all(contrast, "\\*|\\(|\\)", ""),
                contrast = gsub("before", "Before", contrast),
                contrast = gsub("sensors", "Sensors", contrast),
                contrast = gsub("after", "After", contrast),
                effect = ifelse(lower_cl <= 0 & upper_cl >= 0, 
                             F, T)) |>
  dplyr::left_join(M1_sh_contrasts, by = "contrast") |>
  dplyr::mutate(sig = ifelse(p_value < .05, T, F)) |>
  ggplot() +
  aes(y = contrast,
      x = effect_size,
      shape = sig,
      color = effect,
      alpha = effect) +
  geom_linerange(aes(xmin = lower_cl, xmax = upper_cl), size = 1) +
  geom_point(size = 2.5) +
  geom_vline(xintercept = 0, color = "black", linetype = "dashed") +
  scale_alpha_discrete(range = c(.3, 1), guide = "none") +
  scale_shape_manual(values = c(1, 16), guide = "none") +
  scale_color_manual(values = c("black", my_pal[3])) +
  labs(x = "Cohen's d Effect Size",
       y = "Contrast",
       title =  "M1 /ʃ/") +
  theme_classic()

M1_sh_effect_size


```


#### M2

##### Model Summary

The LME model for /sh/ M2 revealed that M2 was significantly higher during sensor placement compared to before sensors. However, M2 after sensor placement did not significantly differ from before sensor placement.

```{r, warning = F, message = F}

M2_sh_mod <- lmer(M2 ~ time_point*group + (1|speaker_id), data = moment_mod_sh)

sjPlot::tab_model(M2_sh_mod,
                  pred.labels = c("Intercept", "Time Point [Sensors]", "Time Point [After]",
                                            "Group [PD]", "Time Point [Sensors] * Group [PD]",
                                            "Time Point [After] * Group [PD]"),
                  dv.labels = "M2 /ʃ/")

```

###### Effect Size of the Model

Partial eta-squared was used to obtain effect sizes for the fixed effects in the model above. Based on the output below, the main effect of time point had a large effect.

```{r, message = F, warning = F}

effectsize::eta_squared(M2_sh_mod, alternative = "two.sided")

```


##### Pairwise Comparisons

Pairwise comparisons using the emmeans package were also conducted. These comparisons also revealed that M2 during sensor placement and after sensor removal was also significantly decreased for control speakers. 

```{r, warning = F, message = F}

emm_M2_sh <- emmeans(M2_sh_mod, specs = pairwise ~ time_point:group)
M2_sh_contrasts <- emm_M2_sh$contrasts |>
  as.data.frame()

M2_sh_contrasts |>
  gt::gt() |>
  fmt_number(decimals = 4)

```

###### Pairwise Effect Sizes

Cohen's d for the pairwise comparisons were also calculated to obtain effect sizes for the pairwise contrasts. For the control speaker, the contrasts comparing before and during sensor placement and during and after sensor placement had a large effect size. This was also observed for the PD speakers

```{r, message = F, warning = F}

M2_sh_contrasts <- M2_sh_contrasts |>
  dplyr::mutate(contrast = gsub("before", "Before", contrast),
                contrast = gsub("sensors", "Sensors", contrast),
                contrast = gsub("after", "After", contrast)) |>
  dplyr::rename(p_value = p.value) |>
  dplyr::select(contrast, p_value)

M2_sh_effect_size <- eff_size(emm_M2_sh, sigma = sigma(M2_sh_mod), edf = df.residual(M2_sh_mod)) |>
  as.data.frame() |>
  janitor::clean_names() |>
  dplyr::mutate(contrast = str_replace_all(contrast, "\\*|\\(|\\)", ""),
                contrast = gsub("before", "Before", contrast),
                contrast = gsub("sensors", "Sensors", contrast),
                contrast = gsub("after", "After", contrast),
                effect = ifelse(lower_cl <= 0 & upper_cl >= 0, 
                             F, T)) |>
  dplyr::left_join(M2_sh_contrasts, by = "contrast") |>
  dplyr::mutate(sig = ifelse(p_value < .05, T, F)) |>
  ggplot() +
  aes(y = contrast,
      x = effect_size,
      shape = sig,
      color = effect,
      alpha = effect) +
  geom_linerange(aes(xmin = lower_cl, xmax = upper_cl), size = 1) +
  geom_point(size = 2.5) +
  geom_vline(xintercept = 0, color = "black", linetype = "dashed") +
  scale_alpha_discrete(range = c(.3, 1), guide = "none") +
  scale_shape_manual(values = c(1, 16), guide = "none") +
  scale_color_manual(values = c("black", my_pal[3])) +
  labs(x = "Cohen's d Effect Size",
       y = "Contrast",
       title =  "M2 /ʃ/") +
  theme_classic()

M2_sh_effect_size


```


## Plot

### Group Differences in M1 for /s/ and /sh/

```{r, warning = F, message = F}

model1 <- M1_s_mod |>
  sjPlot::plot_model(type = "int")

model2 <- M1_sh_mod |>
  sjPlot::plot_model(type = "int")

plot_data1 <- model1[["data"]] |>
  as.data.frame() |>
  dplyr::mutate(condition = factor(x, levels= c(1, 2, 3), 
                                   labels = c("Before", "Sensors", "After")),
                facet = "/s/")

plot_data2 <- model2[["data"]] |>
  as.data.frame() |>
  dplyr::mutate(condition = factor(x, levels= c(1, 2, 3), 
                                   labels = c("Before", "Sensors", "After")),
                facet = "/ʃ/")

plot_data_M1 <- rbind(plot_data1, plot_data2) |>
  dplyr::mutate(facet = factor(facet, levels = c("/s/", "/ʃ/")))

M1_plot <- plot_data_M1 |>
  ggplot() +
  aes(x = condition,
      y = predicted,
      group = group,
      color = group) +
  geom_point(size = 2, position = position_dodge(width = .2)) +
  geom_line(position = position_dodge(width = .2),
            alpha = .8) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high),
                position = position_dodge(width = .2),
                width = 0,
                size = 1,
                alpha = .8) +
  geom_signif(data = data.frame(Group = c("Before", "Sensors", "After")),
              aes(y_position = c(rep(6.25, 6)),
                  xmin = c(1.1, 2.1, 1.1, 1.1, 2.1, 1.1),
                  xmax = c(1.9, 2.9, 2.9, 1.9, 2.9, 1.1),
                  annotations = c("*", "*", NA, NA, NA, NA),
                  group = c(1,2,3,4,5,6)),
              vjust = .5,
              color = my_pal[1],
              tip_length = 0,
              manual = T) +
  facet_wrap("facet") +
  scale_color_manual(values = c(my_pal[1], my_pal[2])) +
  labs(
    x = "Time Point",
    y =" M1 (kHZ)") +
  theme_classic() +
  theme(legend.position = "bottom",
        aspect.ratio = 1)

M1_plot


```


### M2 for /s/ and /sh/

```{r, warning = F, message = F}

model1 <- M2_s_mod |>
  sjPlot::plot_model(type = "int")

model2 <- M2_sh_mod |>
  sjPlot::plot_model(type = "int")

plot_data1 <- model1[["data"]] |>
  as.data.frame() |>
  dplyr::mutate(condition = factor(x, levels= c(1, 2, 3), 
                                   labels = c("Before", "Sensors", "After")),
                facet = "/s/")

plot_data2 <- model2[["data"]] |>
  as.data.frame() |>
  dplyr::mutate(condition = factor(x, levels= c(1, 2, 3), 
                                   labels = c("Before", "Sensors", "After")),
                facet = "/ʃ/")

plot_data_M2 <- rbind(plot_data1, plot_data2) |>
  dplyr::mutate(facet = factor(facet, levels = c("/s/", "/ʃ/")))


M2_plot <- plot_data_M2 |>
  ggplot() +
  aes(x = condition,
      y = predicted,
      group = group,
      color = group) +
  geom_point(size = 2, position = position_dodge(width = .2)) +
  geom_line(position = position_dodge(width = .2),
            alpha = .8) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high),
                position = position_dodge(width = .2),
                width = 0,
                size = 1,
                alpha = .8) +
  geom_signif(data = data.frame(Group = c("Before", "Sensors", "After")),
              aes(y_position = c(rep(3.25, 6)),
                  xmin = c(1.1, 2.1, 1.1, 1.1, 2.1, 1.1),
                  xmax = c(1.9, 2.9, 2.9, 1.9, 2.9, 1.1),
                  annotations = c(NA, NA, NA, NA, "*", NA),
                  group = c(1,2,3,4,5,6)),
              vjust = .5,
              color = my_pal[1],
              tip_length = 0,
              manual = T) +
  facet_wrap("facet") +
  scale_color_manual(values = c(my_pal[1], my_pal[2])) +
  labs(
    x = "Time Point",
    y = "M2 (kHz)") +
  theme_classic() +
  theme(legend.position = "bottom",
        aspect.ratio = 1)

M2_plot


```

### M1 Individual Speaker Plots

```{r}

moment_mod |>
  ggplot() +
  aes(x = time_point,
      y = M1,
      group = speaker_id,
      color = group) +
  geom_line() +
  facet_grid(consonant ~ group) +
  scale_color_manual(values = c(my_pal[1], my_pal[2])) +
  labs(
    x = "Time Point",
    y =" M1 (kHZ)") +
  theme_classic() +
  theme(legend.position = "bottom")

```

### M2 Individual Speaker Plots

```{r}

moment_mod |>
  ggplot() +
  aes(x = time_point,
      y = M2,
      group = speaker_id,
      color = group) +
  geom_line() +
  facet_grid(consonant ~ group) +
  scale_color_manual(values = c(my_pal[1], my_pal[2])) +
  labs(
    x = "Time Point",
    y =" M2 (kHZ)") +
  theme_classic() +
  theme(legend.position = "bottom")

```


```{r, eval = F, warning = F, message = F}

# Combining Spectral Moment Plots

spectral_moment_plot <- ggpubr::ggarrange(M1_plot, M2_plot, ncol = 1, common.legend = T, 
                                          legend = "bottom", align = "hv")

# Exporting Combined Spectral Moment Plot

ggsave("Figures/Spectral_moment.png", plot = spectral_moment_plot)


# Spectral Moment Coefficient Model Output
## (Did a few different ways of making the table)

sjPlot::tab_model(M1_s_mod, M1_sh_mod, M2_s_mod, M2_sh_mod,
                  pred.labels = c("Intercept", "Time Point [Sensors]", "Time Point [After]",
                                            "Group [PD]", "Time Point [Sensors] * Group [PD]",
                                            "Time Point [After] * Group [PD]"),
                  dv.labels = c("M1 /s/", "M1 /ʃ/", "M2 /s/", "M2 /ʃ/"),
                  file = "Tables/spectral_moment_models.html")

sjPlot::tab_model(M1_s_mod, M1_sh_mod,
                  pred.labels = c("Intercept", "Time Point [Sensors]", "Time Point [After]",
                                            "Group [PD]", "Time Point [Sensors] * Group [PD]",
                                            "Time Point [After] * Group [PD]"),
                  dv.labels = c("M1 /s/", "M1 /ʃ/"),
                  file = "Tables/M1_models.html")

sjPlot::tab_model(M2_s_mod, M2_sh_mod,
                  pred.labels = c("Intercept", "Time Point [Sensors]", "Time Point [After]",
                                            "Group [PD]", "Time Point [Sensors] * Group [PD]",
                                            "Time Point [After] * Group [PD]"),
                  dv.labels = c("M2 /s/", "M2 /ʃ/"),
                  file = "Tables/M2_models.html")


```


```{r, echo = F}

# Clearing the environment from all acoustic data
rm(list=ls())

```


# Perceptual Analyses

## Listener Demographics

The listener demographics are presented below. Listeners were women from 18 to 23 years old.

```{r, warning = F, message = F}

# Color Palette for Figures

my_pal <- c("#550527", "#82B12F", "#FAA613")

# Loading in Perceptual Data
perceptual_data <- rio::import("Cleaned Data/perceptual_ratings.csv") |>
  dplyr::mutate(counterbalance = as.factor(counterbalance),
                time_point = factor(time_point, levels = c("before", "sensors", "after")),
                reliability = factor(reliability, levels = c("initial", "reliability")),
                rating_type = factor(rating_type, levels = c("intelligibility", "naturalness")))

listener_demo <- rio::import("Cleaned Data/listener_demographics.csv") |>
  dplyr::mutate(english = as.factor(english),
                age = as.numeric(age),
                gender = as.factor(gender),
                race = as.factor(race),
                ethnicity = as.factor(ethnicity))

speakers <- rio::import("Cleaned Data/articulation_rate.csv") |>
  dplyr::select(speaker_id, group, sex) |>
  dplyr::distinct()

# Listener Demographics Table
demo_listener_table <- listener_demo |>
  select(-c(listener_id, english)) |>
  tbl_summary(type = list(age ~ "continuous",
                          gender ~ "categorical",
                          race ~ "categorical",
                          ethnicity ~ "categorical"),
              statistic = list(all_continuous() ~ "{mean} ({sd})",
                               all_categorical() ~ "{n} ({p}%)"),
              digits = list(everything() ~ c(2)),
              label = list(age ~ "Age",
                           gender ~ "Gender",
                           race ~ "Race",
                           ethnicity ~ "Ethnicity")) |>
  as_gt()

demo_listener_table

demo_listener_table |>
  gtsave("Tables/listener_demo.html")

```


```{r, echo = F, message = F, warning = F}

rm(demo_listener_table, listener_demo)

```


## Intelligibility

Listeners completed 4 repeated ratings (20%) in order to get intrarater reliability. Pearson Product Moment Correlation Coefficient was used to calculate intrarater reliability. Based on the result below, intrarater reliability was strong for intelligibility ratings.

### Intrarater Reliability

```{r, warning = F, message = F}

intel_initial <- perceptual_data |>
  dplyr::filter(rating_type == "intelligibility") |>
  dplyr::filter(reliability == "initial")

intel_rel <- perceptual_data |>
  dplyr::filter(rating_type == "intelligibility") |>
  dplyr::filter(reliability == "reliability") |>
  dplyr::select(listener_id, speaker_id, time_point, cp_section, rating) |>
  dplyr::rename(rating_rel = rating)

intel <- left_join(intel_initial, intel_rel, by = c("listener_id", "speaker_id", 
                                                   "time_point", "cp_section")) |>
  dplyr::filter(!is.na(rating_rel))

cor.test(intel$rating, intel$rating_rel, method = "pearson", use = "complete.obs")

```

### Descriptives

Descriptive results for intelligibility are presented below. Overall, intelligibility is lower for the PD speakers compared to the control speakers. However, for both groups, intelligibility is lower during sensor placement compared to before and after sensor placement.

```{r, warning = F, message = F}

speaker_intel <- intel_initial |>
  dplyr::group_by(speaker_id, time_point) |>
  dplyr::summarize(intel = mean(rating)) |>
  ungroup() |>
  dplyr::left_join(speakers, by = "speaker_id")

speaker_intel |>
  dplyr::select(group, time_point, intel) |>
  tbl_strata(
    strata = group,
    ~.x |>
      tbl_summary(
        by = time_point,
        statistic = list(all_continuous() ~ c("{mean} ({sd})")),
        digits = all_continuous() ~ 2,
        label = list(intel ~ "Intelligibility")
      ))

```

### Model

#### Model Summary

A linear mixed effects model was conducted to evaluate intelligibility changes across the three time points for the two speaker groups. None of the fixed effects in the model were significant. However, there was a trend of decreased intelligibility during sensor placement.

```{r, warning = F, message = F}

intel_mod <- lmer(intel ~ time_point*group + (1|speaker_id), data = speaker_intel)

sjPlot::tab_model(intel_mod, pred.labels = c("Intercept", "Time Point [Sensors]", "Time Point [After]",
                                            "Group [PD]", "Time Point [Sensors] * Group [PD]",
                                            "Time Point [After] * Group [PD]"),
                  dv.labels = "Intelligibility")

```


##### Effect Size

Although none of the fixed effects were significant, the partial eta-sqaured values for the model show a large effect for time point. The main effect of group as well as the interaction between group and time point had large and small effects respectively. However, these results should be interpreted with caution since their confidence intervals contain 0.

```{r}

effectsize::eta_squared(intel_mod, alternative = "two.sided")

```

#### Pairwise Comparisons

Given the large effect size for the main effect of time point, we conducted pairwise comparisons for the model. As noted below, we see significant results for the contrasts  before and during sensor placement and during sensor placement and after sensor removal for the PD speakers. 

```{r, message = F, warning = F}

emm_intel <- emmeans(intel_mod, specs = pairwise ~ time_point:group)
intel_contrasts <- emm_intel$contrasts |>
  as.data.frame()

intel_contrasts |> 
  gt::gt() |>
  fmt_number(decimals = 4)

```

###### Pairwise Effect Sizes

As noted below, several contrasts show a large effect size, such as the difference between control and PD speakers during sensor placement, before and during sensor placement for the PD speakers, and during and after sensor removal for the PD speakers.

```{r, message = F, warning = F}

intel_contrasts <- intel_contrasts |>
  dplyr::mutate(contrast = gsub("before", "Before", contrast),
                contrast = gsub("sensors", "Sensors", contrast),
                contrast = gsub("after", "After", contrast)) |>
  dplyr::rename(p_value = p.value) |>
  dplyr::select(contrast, p_value)

intel_effect_size <- eff_size(emm_intel, sigma = sigma(intel_mod), edf = df.residual(intel_mod)) |>
  as.data.frame() |>
  janitor::clean_names() |>
  dplyr::mutate(contrast = str_replace_all(contrast, "\\*|\\(|\\)", ""),
                contrast = gsub("before", "Before", contrast),
                contrast = gsub("sensors", "Sensors", contrast),
                contrast = gsub("after", "After", contrast),
                effect = ifelse(lower_cl <= 0 & upper_cl >= 0, 
                             F, T)) |>
  dplyr::left_join(intel_contrasts, by = "contrast") |>
  dplyr::mutate(sig = ifelse(p_value < .05, T, F)) |>
  ggplot() +
  aes(y = contrast,
      x = effect_size,
      shape = sig,
      color = effect, 
      alpha = effect) +
  geom_linerange(aes(xmin = lower_cl, xmax = upper_cl), size = 1) +
  geom_point(size = 2.5) +
  geom_vline(xintercept = 0, color = "black", linetype = "dashed") +
  scale_alpha_discrete(range = c(.3, 1), guide = "none") +
  scale_shape_manual(values = c(1, 16), guide = "none") +
  scale_color_manual(values = c("black", my_pal[3])) +
  labs(x = "Cohen's d Effect Size",
       y = "Contrast",
       title =  "Intelligibility") +
  theme_classic()

intel_effect_size

```

## Naturalness

### Intrarater Reliability

Intrarater reliability was measured using Pearson Product Moment Correlation Coefficient. The results show a moderate-strong reliability.

```{r, warning = F, message = F}

nat_initial <- perceptual_data |>
  dplyr::filter(rating_type == "naturalness") |>
  dplyr::filter(reliability == "initial")

nat_rel <- perceptual_data |>
  dplyr::filter(rating_type == "naturalness") |>
  dplyr::filter(reliability == "reliability") |>
  dplyr::select(listener_id, speaker_id, time_point, cp_section, rating) |>
  dplyr::rename(rating_rel = rating)

nat <- left_join(nat_initial, nat_rel, by = c("listener_id", "speaker_id", 
                                                   "time_point", "cp_section")) |>
  dplyr::filter(!is.na(rating_rel))

cor.test(nat$rating, nat$rating_rel, method = "pearson", use = "complete.obs")

```

### Descriptives

Naturalness ratings appear to be lower for both groups compared to intelligility ratings. However, the patterns of results appear to be similar to the intelligibility ratings.

```{r, warning = F, message = F}

speaker_nat <- nat_initial |>
  dplyr::group_by(speaker_id, time_point) |>
  dplyr::summarize(nat = mean(rating)) |>
  ungroup() |>
  dplyr::left_join(speakers, by = "speaker_id")

speaker_nat |>
  dplyr::select(group, time_point, nat) |>
  tbl_strata(
    strata = group,
    ~.x |>
      tbl_summary(
        by = time_point,
        statistic = list(all_continuous() ~ c("{mean} ({sd})")),
        digits = all_continuous() ~ 2,
        label = list(nat ~ "Naturalness")
      ))

```

### Model

A linear effects model was conducted to evaluate how naturalness ratings changed between the three time points (before, sensors, and after) for the two speaker groups (PD and control). The LME results showed that naturalness was significantly lower during sensor placement compared to before sensors and that PD speakers had lower overall naturalness ratings. Naturalness ratings did not significantly differ before and after sensor placement. 

#### Model Summary

```{r, warning = F, message = F}

nat_mod <- lmer(nat ~ time_point*group + (1|speaker_id), data = speaker_nat)

sjPlot::tab_model(nat_mod, pred.labels = c("Intercept", "Time Point [Sensors]", "Time Point [After]",
                                            "Group [PD]", "Time Point [Sensors] * Group [PD]",
                                            "Time Point [After] * Group [PD]"),
                  dv.labels = "Naturalness")

```

##### Effect Size

Partial eta-squared analyses show large effect sizes for the main effects of time point and group for the naturalness model. A moderate effect size for the interaction was shown. However, this result is likely not important since the confidence interval contains 0.

```{r, message = F, warning = F}

effectsize::eta_squared(nat_mod, alternative = "two.sided")

```

#### Pairwise Comparisons

Pairwise comparisons also found that naturalness significantly increased from sensor placement to after sensor placement for both the PD and control speakers.

```{r, warning = F, message = F}

emm_nat <- emmeans(nat_mod, specs = pairwise ~ time_point:group)
nat_contrasts <- emm_nat$contrasts |>
  as.data.frame()

nat_contrasts |>
  gt::gt() |>
  fmt_number(decimals = 4)

```


##### Pairwise Effect Sizes

Cohen's d effect sizes were calculated for these pairwise contrasts. As seen below, large effects were seen for the before and during sensor contrasts, and the during and after contrasts for both the control and PD speaker groups. A large effect size was also seen for the before and after contrast for the PD speakers. Large effect sizes were also seen for all contrasts between PD and control speakers at each time point.

```{r, warning = F, message = F}

nat_contrasts <- nat_contrasts |>
  dplyr::mutate(contrast = gsub("before", "Before", contrast),
                contrast = gsub("sensors", "Sensors", contrast),
                contrast = gsub("after", "After", contrast)) |>
  dplyr::rename(p_value = p.value) |>
  dplyr::select(contrast, p_value)

nat_effect_size <- eff_size(emm_nat, sigma = sigma(nat_mod), edf = df.residual(nat_mod)) |>
  as.data.frame() |>
  janitor::clean_names() |>
  dplyr::mutate(contrast = str_replace_all(contrast, "\\*|\\(|\\)", ""),
                contrast = gsub("before", "Before", contrast),
                contrast = gsub("sensors", "Sensors", contrast),
                contrast = gsub("after", "After", contrast),
                effect = ifelse(lower_cl <= 0 & upper_cl >= 0, 
                             F, T)) |>
  dplyr::left_join(nat_contrasts, by = "contrast") |>
  dplyr::mutate(sig = ifelse(p_value < .05, T, F)) |>
  ggplot() +
  aes(y = contrast,
      x = effect_size,
      shape = sig,
      color = effect,
      alpha = effect) +
  geom_linerange(aes(xmin = lower_cl, xmax = upper_cl), size = 1) +
  geom_point(size = 2.5) +
  geom_vline(xintercept = 0, color = "black", linetype = "dashed") +
  scale_alpha_discrete(range = c(.3, 1), guide = "none") +
  scale_shape_manual(values = c(1, 16), guide = "none") +
  scale_color_manual(values = c("black", my_pal[3])) +
  labs(x = "Cohen's d Effect Size",
       y = "Contrast",
       title =  "Naturalness") +
  theme_classic()

nat_effect_size


```

## Perceptual Plot

### Group Differences

```{r, warning = F, message = F}

model1 <- intel_mod |>
  sjPlot::plot_model(type = "int")

model2 <- nat_mod |>
  sjPlot::plot_model(type = "int")

plot_data1 <- model1[["data"]] |>
  as.data.frame() |>
  dplyr::mutate(condition = factor(x, levels= c(1, 2, 3), 
                                   labels = c("Before", "Sensors", "After")),
                facet = "Intelligibility")

plot_data2 <- model2[["data"]] |>
  as.data.frame() |>
  dplyr::mutate(condition = factor(x, levels= c(1, 2, 3), 
                                   labels = c("Before", "Sensors", "After")),
                facet = "Naturalness")

plot_data_percep <- rbind(plot_data1, plot_data2) |>
  dplyr::mutate(facet = factor(facet, levels = c("Intelligibility", "Naturalness")))


plot_data_percep |>
  ggplot() +
  aes(x = condition,
      y = predicted,
      group = group,
      color = group) +
  geom_point(size = 2, position = position_dodge(width = .3)) +
  geom_line(position = position_dodge(width = .3),
            alpha = .8) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high),
                position = position_dodge(width = .3),
                width = 0,
                size = 1,
                alpha = .8) +
  geom_signif(data = data.frame(Group = c("Before", "Sensors", "After")),
              aes(y_position = c(rep(120, 6)),
                  xmin = c(1.1, 2.1, 1.1, 1.1, 2.1, 1.1),
                  xmax = c(1.9, 2.9, 2.9, 1.9, 2.9, 1.1),
                  annotations = c(NA, NA, NA, "*", "*", NA),
                  group = c(1,2,3,4,5,6)),
              vjust = .5,
              color = my_pal[1],
              tip_length = 0,
              manual = T) +
  geom_signif(data = data.frame(Group = c("Before", "Sensors", "After")),
              aes(y_position = c(rep(110, 6)),
                  xmin = c(1.1, 2.1, 1.1, 1.1, 2.1, 1.1),
                  xmax = c(1.9, 2.9, 2.9, 1.9, 2.9, 1.1),
                  annotations = c("*", "*", NA, "*", "*", NA),
                  group = c(1,2,3,4,5,6)),
              vjust = .5,
              color = my_pal[2],
              tip_length = 0,
              manual = T) +
  geom_signif(data = data.frame(Group = c("Before", "Sensors", "After")),
              aes(y_position = c(rep(100, 6)),
                  xmin = c(.9, 1.9, 2.9, .9, 1.9, 2.9),
                  xmax = c(1.1, 2.1, 3.1, 1.1, 2.1, 3.1),
                  annotations = c(NA, NA, NA, NA, "*", NA),
                  group = c(1,2,3,4,5,6)),
              vjust = .5,
              color = "black",
              tip_length = 0,
              manual = T) +
  facet_wrap("facet") +
  scale_color_manual(values = c(my_pal[1], my_pal[2])) +
  scale_y_continuous(breaks = c(0, 25, 50, 75, 100)) +
  labs(
    x = "Time Point",
    y = "VAS Rating") +
  theme_classic() +
  coord_cartesian(ylim = c(0, 125)) +
  theme(legend.position = "bottom",
        aspect.ratio = 1)

ggsave("Figures/perceptual_plot.png", plot = last_plot())

```

### Individual Plot

```{r}

plot_df <- speaker_intel |>
  dplyr::mutate(type = "Intelligibility") |>
  dplyr::rename(rating = intel)

nat_df <- speaker_nat |>
  dplyr::mutate(type = "Naturalness") |>
  dplyr::rename(rating = nat)

plot_df <- plot_df |>
  rbind(nat_df)

plot_df |>
  ggplot() +
  aes(x = time_point,
      y = rating,
      group = speaker_id,
      color = group) +
  geom_line() +
  facet_grid(type ~ group) +
  scale_color_manual(values = c(my_pal[1], my_pal[2])) +
  labs(
    x = "Time Point",
    y = "VAS Rating") +
  theme_classic() +
  coord_cartesian(ylim = c(0, 100)) +
  theme(legend.position = "bottom")

```



```{r, eval = F}

sjPlot::tab_model(intel_mod, nat_mod, 
                  pred.labels = c("Intercept", "Time Point [Sensors]", "Time Point [After]",
                                            "Group [PD]", "Time Point [Sensors] * Group [PD]",
                                            "Time Point [After] * Group [PD]"),
                  dv.labels = c("Intelligibility", "Naturalness"),
                  file = "Tables/perceptual_mods.html")

```

